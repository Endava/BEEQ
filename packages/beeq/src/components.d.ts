/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { TAccordionAppearance, TAccordionSize } from "./components/accordion/bq-accordion.types";
import { TAlertBorderRadius, TAlertType } from "./components/alert/bq-alert.types";
import { TAvatarShape, TAvatarSize } from "./components/avatar/bq-avatar.types";
import { TBadgeSize } from "./components/badge/bq-badge.types";
import { TButtonAppearance, TButtonBorderRadius, TButtonSize, TButtonType, TButtonVariant } from "./components/button/bq-button.types";
import { TCardBorderRadius, TCardType } from "./components/card/bq-card.types";
import { FloatingUIPlacement } from "./services/interfaces";
import { TInputType, TInputValidation, TInputValue } from "./components/input/bq-input.types";
import { TDialogBorderRadius, TDialogFooterAppearance, TDialogSize } from "./components/dialog/bq-dialog.types";
import { TDividerOrientation, TDividerStrokeLinecap, TDividerTitleAlignment } from "./components/divider/bq-divider.types";
import { TDrawerPlacement } from "./components/drawer/bq-drawer.types";
import { TEmptyStateSize } from "./components/empty-state/bq-empty-state.types";
import { TIconWeight } from "./components/icon/bq-icon.types";
import { TNotificationBorderRadius, TNotificationType } from "./components/notification/bq-notification.types";
import { TProgressBorderShape, TProgressThickness, TProgressType } from "./components/progress/bq-progress.types";
import { TRadioGroupOrientation } from "./components/radio-group/bq-radio-group.types";
import { TSelectValue } from "./components/select/bq-select";
import { TSideMenuAppearance, TSideMenuSize } from "./components/side-menu/bq-side-menu.types";
import { TSliderType, TSliderValue } from "./components/slider/bq-slider.types";
import { TSpinnerSize, TSpinnerTextPosition } from "./components/spinner/bq-spinner.types";
import { TStatusType } from "./components/status/bq-status.types";
import { TStepsSize, TStepsType } from "./components/steps/bq-steps.types";
import { TStepItemStatus } from "./components/step-item/bq-step-item.types";
import { TSwitchInnerLabel, TSwitchJustifyContent } from "./components/switch/bq-switch.types";
import { TTabSize } from "./components/tab/bq-tab.types";
import { TTagBorderRadius, TTagColor, TTagSize, TTagVariant } from "./components/tag/bq-tag.types";
import { TTextareaAutoCapitalize, TTextareaWrap } from "./components/textarea/bq-textarea.types";
import { TToastBorderRadius, TToastPlacement, TToastType } from "./components/toast/bq-toast.types";
export { TAccordionAppearance, TAccordionSize } from "./components/accordion/bq-accordion.types";
export { TAlertBorderRadius, TAlertType } from "./components/alert/bq-alert.types";
export { TAvatarShape, TAvatarSize } from "./components/avatar/bq-avatar.types";
export { TBadgeSize } from "./components/badge/bq-badge.types";
export { TButtonAppearance, TButtonBorderRadius, TButtonSize, TButtonType, TButtonVariant } from "./components/button/bq-button.types";
export { TCardBorderRadius, TCardType } from "./components/card/bq-card.types";
export { FloatingUIPlacement } from "./services/interfaces";
export { TInputType, TInputValidation, TInputValue } from "./components/input/bq-input.types";
export { TDialogBorderRadius, TDialogFooterAppearance, TDialogSize } from "./components/dialog/bq-dialog.types";
export { TDividerOrientation, TDividerStrokeLinecap, TDividerTitleAlignment } from "./components/divider/bq-divider.types";
export { TDrawerPlacement } from "./components/drawer/bq-drawer.types";
export { TEmptyStateSize } from "./components/empty-state/bq-empty-state.types";
export { TIconWeight } from "./components/icon/bq-icon.types";
export { TNotificationBorderRadius, TNotificationType } from "./components/notification/bq-notification.types";
export { TProgressBorderShape, TProgressThickness, TProgressType } from "./components/progress/bq-progress.types";
export { TRadioGroupOrientation } from "./components/radio-group/bq-radio-group.types";
export { TSelectValue } from "./components/select/bq-select";
export { TSideMenuAppearance, TSideMenuSize } from "./components/side-menu/bq-side-menu.types";
export { TSliderType, TSliderValue } from "./components/slider/bq-slider.types";
export { TSpinnerSize, TSpinnerTextPosition } from "./components/spinner/bq-spinner.types";
export { TStatusType } from "./components/status/bq-status.types";
export { TStepsSize, TStepsType } from "./components/steps/bq-steps.types";
export { TStepItemStatus } from "./components/step-item/bq-step-item.types";
export { TSwitchInnerLabel, TSwitchJustifyContent } from "./components/switch/bq-switch.types";
export { TTabSize } from "./components/tab/bq-tab.types";
export { TTagBorderRadius, TTagColor, TTagSize, TTagVariant } from "./components/tag/bq-tag.types";
export { TTextareaAutoCapitalize, TTextareaWrap } from "./components/textarea/bq-textarea.types";
export { TToastBorderRadius, TToastPlacement, TToastType } from "./components/toast/bq-toast.types";
export namespace Components {
    interface BqAccordion {
        /**
          * The appearance style of accordion
         */
        "appearance": TAccordionAppearance;
        /**
          * If true accordion is disabled
         */
        "disabled": boolean;
        /**
          * If true accordion is expanded
         */
        "expanded": boolean;
        /**
          * If true accordion expand icon is rotate 180deg when expanded
         */
        "rotate": boolean;
        /**
          * The size of accordion
         */
        "size": TAccordionSize;
    }
    interface BqAccordionGroup {
        /**
          * The appearance style of accordion to be applied to all accordions
         */
        "appearance": TAccordionAppearance;
        /**
          * If true all accordions are expanded
         */
        "expandAll": boolean;
        /**
          * If true multiple accordions can be expanded at the same time
         */
        "multiple": boolean;
        /**
          * The size of accordion to be applied to all accordions
         */
        "size": TAccordionSize;
    }
    interface BqAlert {
        /**
          * If true, the alert will automatically hide after the specified amount of time
         */
        "autoDismiss": boolean;
        /**
          * The corner radius of the alert component
         */
        "border": TAlertBorderRadius;
        /**
          * If true, the close button at the top right of the alert won't be shown
         */
        "disableClose": boolean;
        /**
          * Method to be called to hide the alert component
         */
        "hide": () => Promise<void>;
        /**
          * If true, the alert icon won't be shown
         */
        "hideIcon": boolean;
        /**
          * If true, the alert will be shown
         */
        "open": boolean;
        /**
          * Method to be called to show the alert component
         */
        "show": () => Promise<void>;
        /**
          * If true, the alert component will remain fixed at the top of the page, occupying the full viewport
         */
        "sticky": boolean;
        /**
          * The length of time, in milliseconds, after which the alert will close itself. Only valid if `autoDismiss="true"`
         */
        "time": number;
        /**
          * Type of Alert
         */
        "type": TAlertType;
    }
    interface BqAvatar {
        /**
          * Alternate text for the avatar image if the image cannot be displayed
         */
        "altText": string;
        /**
          * The image source to load on the avatar (this can be also a base64 encoded image)
         */
        "image": string;
        /**
          * The text to display on avatar
         */
        "initials": string;
        /**
          * A text to use for describing the avatar on assistive devices
         */
        "label": string;
        /**
          * The shape of the avatar
         */
        "shape": TAvatarShape;
        /**
          * The size of the avatar
         */
        "size": TAvatarSize;
    }
    interface BqBadge {
        /**
          * Badge background color. The value should be a valid value of the palette color
         */
        "backgroundColor"?: string;
        /**
          * The size of the badge. Relevant if badge has no content.
         */
        "size"?: TBadgeSize;
        /**
          * Badge number color. The value should be a valid value of the palette color
         */
        "textColor"?: string;
    }
    interface BqBreadcrumb {
        /**
          * The `aria-label` attribute to describe the type of navigation
         */
        "ariaLabel": string;
    }
    interface BqBreadcrumbItem {
        /**
          * The aria-label that corresponds to the full title of the destination page. This won't be shown in the page, but it will be used by screen readers and other assistive devices.
         */
        "ariaLabel": string;
        /**
          * If set, the breadcrumb item will be rendered as an `<a>` with this `href`, otherwise, a `<button>` will be rendered.
         */
        "href": string;
        /**
          * If true, the item is the last element inside breadcrumb
         */
        "isLastItem": boolean;
        /**
          * Where to display the link in the browser context. Relevant only if `href` is set.
         */
        "rel": string;
        /**
          * Where to display the link in the browser context. Relevant only if `href` is set.
         */
        "target": '_blank' | '_parent' | '_self' | '_top';
    }
    /**
     * Buttons are designed for users to take action on a page or a screen.
     */
    interface BqButton {
        /**
          * The appearance style to apply to the button
         */
        "appearance": TButtonAppearance;
        /**
          * If `true`, it will make the button fit to its parent width.
         */
        "block": boolean;
        /**
          * The corner radius of the button
         */
        "border": TButtonBorderRadius;
        /**
          * If true, the button will be disabled (no interaction allowed)
         */
        "disabled": boolean;
        /**
          * Tells the browser to treat the linked URL as a download. Only used when `href` is set. Details: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-download
         */
        "download"?: string;
        /**
          * When set, the underlying button will be rendered as an `<a>` with this `href` instead of a `<button>`
         */
        "href": string;
        /**
          * It determinate how the content should be aligned
         */
        "justifyContent": 'left' | 'center' | 'right';
        /**
          * If `true` it will display the button in a loading state
         */
        "loading": boolean;
        /**
          * The size of the button
         */
        "size": TButtonSize;
        /**
          * Where to display the linked URL, as the name for a browsing context (a `tab`, `window`, or `<iframe>`) Details: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-target
         */
        "target": '_blank' | '_parent' | '_self' | '_top';
        /**
          * The default behavior of the button
         */
        "type": TButtonType;
        /**
          * The variant of button to apply on top of the appearance (applicable only to `appearance="primary"`)
         */
        "variant": TButtonVariant;
    }
    interface BqCard {
        /**
          * The corner radius of the card component
         */
        "border": TCardBorderRadius;
        /**
          * Type of card component
         */
        "type": TCardType;
    }
    interface BqCheckbox {
        /**
          * If true checkbox displays background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * If true checkbox is checked
         */
        "checked"?: boolean;
        /**
          * If true checkbox is disabled
         */
        "disabled"?: boolean;
        /**
          * The form ID that the checkbox is associated with
         */
        "formId"?: string;
        /**
          * A state that is neither checked nor unchecked
         */
        "indeterminate"?: boolean;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * If `true`, it will indicate that the user must specify a value for the checkbox before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * Remove focus from the native `<input>` HTML element used under the hood. Use this method instead of the global `element.blur()`.
         */
        "vBlur": () => Promise<void>;
        /**
          * Simulate a click event on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.click()`.
         */
        "vClick": () => Promise<void>;
        /**
          * Sets focus on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.focus()`.
         */
        "vFocus": () => Promise<void>;
        /**
          * A string representing the value of the checkbox. Primarily used to differentiate a list of related checkboxes that have the same name.
         */
        "value": string;
    }
    interface BqDatePicker {
        /**
          * If `true`, the Date picker input will be focused on component render
         */
        "autofocus": boolean;
        /**
          * Clears the selected value.
          * @return 
          * @memberof BqInput
         */
        "clear": () => Promise<void>;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * If `true`, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the Date picker input is disabled or not. If `true`, the Date picker is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the Date picker panel and the input element.
         */
        "distance"?: number;
        /**
          * The ID of the form that the Date picker input belongs to.
         */
        "form"?: string;
        /**
          * If `true`, the Date picker panel will remain open after a selection date is made.
         */
        "keepOpenOnSelect"?: boolean;
        /**
          * Number of months to show when range is `true`
         */
        "months": number;
        /**
          * The Date picker input name.
         */
        "name": string;
        /**
          * If `true`, the Date picker panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the Date picker panel.
         */
        "panelHeight"?: string;
        /**
          * The Date picker input placeholder text value
         */
        "placeholder"?: string;
        /**
          * Position of the Date picker panel
         */
        "placement"?: FloatingUIPlacement;
        /**
          * If `true`, the Date picker panel will accepts more than 1 month to display
         */
        "range": boolean;
        /**
          * Indicates whether or not the Date picker input is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * Represents the skidding between the Date picker panel and the input element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the Date picker panel
         */
        "strategy"?: 'fixed' | 'absolute';
        /**
          * The validation status of the Select input.
          * @remarks This property is used to indicate the validation status of the select input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus": TInputValidation;
        /**
          * The select input value, it can be used to reset the field to a previous value
         */
        "value": TInputValue;
    }
    interface BqDialog {
        /**
          * Corder radius of the dialog component
         */
        "border": TDialogBorderRadius;
        /**
          * Dismiss or cancel the dialog
         */
        "cancel": () => Promise<void>;
        /**
          * If true, the backdrop overlay won't be shown when the dialog opens
         */
        "disableBackdrop": boolean;
        /**
          * If true, the dialog will not close when clicking on the backdrop overlay
         */
        "disableCloseClickOutside": boolean;
        /**
          * If true, the dialog will not close when the [Esc] key is press
         */
        "disableCloseEscKeydown": boolean;
        /**
          * The appearance of footer
         */
        "footerAppearance": TDialogFooterAppearance;
        /**
          * Closes the dialog
         */
        "hide": () => Promise<void>;
        /**
          * If true, it hides the close button
         */
        "hideCloseButton": boolean;
        /**
          * If true, the dialog will be shown as open
         */
        "open": boolean;
        /**
          * Open the dialog
         */
        "show": () => Promise<void>;
        /**
          * The size of the dialog
         */
        "size": TDialogSize;
    }
    interface BqDivider {
        /**
          * If true, the divider has a dashed pattern
         */
        "dashed": boolean;
        /**
          * The default orientation of the divider
         */
        "orientation": TDividerOrientation;
        /**
          * Set the min width of the divider's stroke when text is not centered. Value expressed in px
         */
        "strokeBasis"?: number;
        /**
          * Set the stroke color of the divider. The value should be a valid value of the palette color
         */
        "strokeColor"?: string;
        /**
          * Set the gap of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeDashGap"?: number;
        /**
          * Set the width of each dash of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeDashWidth"?: number;
        /**
          * Set the line of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeLinecap"?: TDividerStrokeLinecap;
        /**
          * Set the thickness of the divider's stroke. Value expressed in px
         */
        "strokeThickness"?: number;
        /**
          * Set the alignment of the title on the main axis of the divider (horizontal / vertical)
         */
        "titleAlignment"?: TDividerTitleAlignment;
    }
    interface BqDrawer {
        /**
          * If true, the drawer will not close when clicking outside the panel
         */
        "closeOnClickOutside": boolean;
        /**
          * If true, the dialog will not close when the [Esc] key is pressed
         */
        "closeOnEsc": boolean;
        /**
          * If true, the backdrop overlay will be shown when the drawer opens
         */
        "enableBackdrop": boolean;
        /**
          * Method to be called to hide the drawer component
         */
        "hide": () => Promise<void>;
        /**
          * If true, the drawer component will be shown
         */
        "open": boolean;
        /**
          * Defines the position of the drawer
         */
        "placement": TDrawerPlacement;
        /**
          * Method to be called to show the drawer component
         */
        "show": () => Promise<void>;
    }
    interface BqDropdown {
        /**
          * If true, the dropdown panel will be visible and won't be shown.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the panel and the trigger element.
         */
        "distance"?: number;
        /**
          * If true, the panel will remain open after a selection is made.
         */
        "keepOpenOnSelect"?: boolean;
        /**
          * If true, the panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the dropdown panel
         */
        "panelHeight"?: string;
        /**
          * Position of the panel
         */
        "placement"?: FloatingUIPlacement;
        /**
          * Whether the panel should have the same width as the trigger element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the panel and the trigger element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the panel
         */
        "strategy"?: 'fixed' | 'absolute';
    }
    interface BqEmptyState {
        /**
          * The size of the empty state component
         */
        "size": TEmptyStateSize;
    }
    /**
     * Icons are simplified images that graphically explain the meaning of an object on the screen.
     */
    interface BqIcon {
        /**
          * Set the stroke color of the SVG. The value should be a valid value of the palette color
         */
        "color"?: string;
        /**
          * Label for the icon, used for accessibility
         */
        "label"?: string;
        /**
          * Icon name to load. Please check all available icons [here](https://phosphoricons.com/)
         */
        "name": string;
        /**
          * Set the size of the SVG
         */
        "size"?: string | number;
        /**
          * Set the source of the SVG. If the source is set, the name property will be ignored
         */
        "src"?: string;
        /**
          * It set the icon weight/style
         */
        "weight"?: TIconWeight;
    }
    interface BqInput {
        /**
          * Controls whether or not the input field should be capitalized and how. Possible values are 'off', 'none', 'on', 'sentences', 'words', and 'characters'. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize
         */
        "autocapitalize": string;
        /**
          * Specifies whether or not the input field should have autocomplete enabled. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values
         */
        "autocomplete": string;
        /**
          * Controls whether or not the input field should have autocorrect enabled. Possible values are 'on' and 'off'.
         */
        "autocorrect": 'on' | 'off';
        /**
          * If true, the input will be focused on component render
         */
        "autofocus": boolean;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `bqInput` event after the input value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If true, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the input is disabled or not. If `true`, the input is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * The ID of the form that the input field belongs to.
         */
        "form"?: string;
        /**
          * The inputmode attribute specifies what kind of input mechanism would be most helpful for users entering content into the input field. This allows a browser to display an appropriate virtual keyboard while editing. Possible values are 'none', 'text', 'decimal', 'numeric', 'tel', 'search', 'email', 'url', and 'date'.
         */
        "inputmode"?: string;
        /**
          * The maximum value that the input field can accept. Only applies to date and number input types.
         */
        "max"?: number | string;
        /**
          * The maximum number of characters that the input field can accept.
         */
        "maxlength": number;
        /**
          * The minimum value that the input field can accept. Only applies to date and number input types.
         */
        "min"?: number | string;
        /**
          * The minimum number of characters that the input field can accept.
         */
        "minlength": number;
        /**
          * The input field name.
         */
        "name": string;
        /**
          * Specifies a regular expression the form control's value should match. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/pattern
         */
        "pattern"?: string;
        /**
          * The input placeholder text value
         */
        "placeholder"?: string;
        /**
          * If true, the input field cannot be modified.
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the input field is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * A number that specifies the granularity that the value must adhere to. Valid for date, month, week, time, datetime-local, number, and range. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#step
         */
        "step": number | 'any';
        /**
          * The type attribute specifies the type of input field to display. Possible values are 'text', 'password', 'email', 'number', 'tel', 'search', 'url', and more. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types
         */
        "type": TInputType;
        /**
          * The validation status of the input.
          * @remarks This property is used to indicate the validation status of the input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus": TInputValidation;
        /**
          * The input value, it can be used to reset the input to a previous value
         */
        "value": TInputValue;
    }
    interface BqNotification {
        /**
          * If true, the notification will automatically hide after the specified amount of time
         */
        "autoDismiss": boolean;
        /**
          * The corder radius of the notification component
         */
        "border": TNotificationBorderRadius;
        /**
          * If true, the close button at the top right of the notification won't be shown
         */
        "disableClose": boolean;
        /**
          * Method to be called to hide the notification component
         */
        "hide": () => Promise<void>;
        /**
          * If true, the notification icon won't be shown
         */
        "hideIcon": boolean;
        /**
          * If true, the notification will be shown
         */
        "open": boolean;
        /**
          * Method to be called to show the notification component
         */
        "show": () => Promise<void>;
        /**
          * The length of time, in milliseconds, after which the notification will close itself. Only valid if `autoDismiss="true"`
         */
        "time": number;
        /**
          * This method can be used to display notifications in a fixed-position element that allows for stacking multiple notifications vertically
         */
        "toast": () => Promise<void>;
        /**
          * Type of Notification
         */
        "type": TNotificationType;
    }
    interface BqOption {
        /**
          * If true, the option is disabled.
         */
        "disabled"?: boolean;
        /**
          * If true, the option is hidden.
         */
        "hidden": boolean;
        /**
          * If true, the option is selected and active.
         */
        "selected": boolean;
        /**
          * A string representing the value of the option. Can be used to identify the item
         */
        "value"?: string;
    }
    interface BqOptionGroup {
    }
    interface BqOptionList {
        /**
          * Aria label for the list.
         */
        "ariaLabel": string;
    }
    interface BqPanel {
        /**
          * Represents the distance (gutter or margin) between the panel and the trigger element.
         */
        "distance"?: number;
        /**
          * If true, the panel will be visible.
         */
        "open"?: boolean;
        /**
          * Position of the panel
         */
        "placement"?: FloatingUIPlacement;
        /**
          * Whether the panel should have the same width as the trigger element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the panel and the trigger element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the panel
         */
        "strategy"?: 'fixed' | 'absolute';
    }
    interface BqProgress {
        /**
          * It will set the border style of the progress bar
         */
        "borderShape": TProgressBorderShape;
        /**
          * If `true`, a tooltip will be shown displaying the progress value
         */
        "enableTooltip": boolean;
        /**
          * If `true` the indeterminate state of progress bar is enabled
         */
        "indeterminate": boolean;
        /**
          * If `true`, a label text showing the value (in percentage) will be shown
         */
        "label": boolean;
        /**
          * Progress bar thickness
         */
        "thickness": TProgressThickness;
        /**
          * Progress type
         */
        "type": TProgressType;
        /**
          * A number representing the current value of the progress bar
         */
        "value": number;
    }
    interface BqRadio {
        /**
          * If true radio displays background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * If true radio input is checked
         */
        "checked"?: boolean;
        /**
          * If true radio input is disabled
         */
        "disabled"?: boolean;
        /**
          * The form ID that the radio input is associated with
         */
        "formId"?: string;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * If `true`, it will indicate that the user must specify a value for the radio before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * Remove focus from the native `<input>` HTML element used under the hood. Use this method instead of the global `element.blur()`.
         */
        "vBlur": () => Promise<void>;
        /**
          * Simulate a click event on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.click()`.
         */
        "vClick": () => Promise<void>;
        /**
          * Sets focus on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.focus()`.
         */
        "vFocus": () => Promise<void>;
        /**
          * A string representing the value of the radio.
         */
        "value": string;
    }
    interface BqRadioGroup {
        /**
          * If true, all radio inputs in the group will display a background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * A number representing the delay time (in milliseconds) that `bqChange` event handler gets triggered once the value change
         */
        "debounceTime": number;
        /**
          * If true radio inputs are disabled
         */
        "disabled"?: boolean;
        /**
          * If true displays fieldset
         */
        "fieldset"?: boolean;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * The display orientation of the radio inputs
         */
        "orientation": TRadioGroupOrientation;
        /**
          * A string representing the value of the radio.
         */
        "value"?: string;
    }
    interface BqSelect {
        /**
          * If true, the Select input will be focused on component render
         */
        "autofocus": boolean;
        /**
          * Clears the selected value.
          * @return 
          * @memberof BqSelect
         */
        "clear": () => Promise<void>;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `bqInput` event after the input value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If true, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the Select input is disabled or not. If `true`, the Select is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the Select panel and the input element.
         */
        "distance"?: number;
        /**
          * The ID of the form that the Select input belongs to.
         */
        "form"?: string;
        /**
          * If true, the Select panel will remain open after a selection is made.
         */
        "keepOpenOnSelect"?: boolean;
        /**
          * The maximum number of tags to display when multiple selection is enabled
         */
        "maxTagsVisible": number;
        /**
          * If true, the Select input will allow multiple selections.
         */
        "multiple"?: boolean;
        /**
          * The Select input name.
         */
        "name": string;
        /**
          * If true, the Select panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the Select panel.
         */
        "panelHeight"?: string;
        /**
          * The Select input placeholder text value
         */
        "placeholder"?: string;
        /**
          * Position of the Select panel
         */
        "placement"?: FloatingUIPlacement;
        /**
          * If true, the list of options cannot be filtered (searching won't be available)
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the Select input is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * Whether the panel should have the Select same width as the input element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the Select panel and the input element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the Select panel
         */
        "strategy"?: 'fixed' | 'absolute';
        /**
          * The validation status of the Select input.
          * @remarks This property is used to indicate the validation status of the select input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus": TInputValidation;
        /**
          * The select input value, it can be used to reset the field to a previous value
         */
        "value": TSelectValue;
    }
    interface BqSideMenu {
        /**
          * It sets a predefined appearance of the side menu
         */
        "appearance": TSideMenuAppearance;
        /**
          * If true, the container will reduce its width
         */
        "collapse": boolean;
        /**
          * It sets the size of the navigation menu items
         */
        "size": TSideMenuSize;
        /**
          * Toggle the collapse state of the side menu
         */
        "toggleCollapse": () => Promise<void>;
    }
    interface BqSideMenuItem {
        /**
          * If true, the menu item will be shown as active/selected.
         */
        "active": boolean;
        /**
          * If true, the item label and suffix will be hidden and the with will be reduce according to its parent
         */
        "collapse": boolean;
        /**
          * If true, the menu item will be disabled (no interaction allowed)
         */
        "disabled": boolean;
    }
    interface BqSlider {
        /**
          * The amount of time, in milliseconds, to wait to trigger the `bqChange` event after each value change.
         */
        "debounceTime": number;
        /**
          * If `true` the slider is disabled.
         */
        "disabled"?: boolean;
        /**
          * If `true`, a tooltip will be shown displaying the progress value
         */
        "enableTooltip": boolean;
        /**
          * If `true` it will show the value label on a side of the slider track area
         */
        "enableValueIndicator"?: boolean;
        /**
          * A number representing the amount to remain between the minimum and maximum values (only for range type).
         */
        "gap": number;
        /**
          * A number representing the max value of the slider.
         */
        "max": number;
        /**
          * A number representing the min value of the slider.
         */
        "min": number;
        /**
          * A number representing the step of the slider. ⚠️ Please notice that the value (or list of values if the slider type is `range`) will be rounded to the nearest multiple of `step`.
         */
        "step": number;
        /**
          * If `true`, a tooltip will always display the progress value. It relies on enableTooltip and if enableTooltip is false, tooltipAlwaysVisible cannot be true.
         */
        "tooltipAlwaysVisible": boolean;
        /**
          * It defines the type of slider to display
         */
        "type": TSliderType;
        /**
          * The value of the slider. - If the slider type is `single`, the value is a number. - If the slider type is `range`, the value is an array of two numbers (the first number represents the `min` value and the second number represents the `max` value).
         */
        "value": TSliderValue;
    }
    /**
     * Spinners are designed for users to display data loading.
     */
    interface BqSpinner {
        /**
          * If `false`, the animation on the icon element will be stopped
         */
        "animation"?: boolean;
        /**
          * It defines the size of the icon element displayed
         */
        "size": TSpinnerSize;
        /**
          * It defines the position of the label text
         */
        "textPosition": TSpinnerTextPosition;
    }
    interface BqStatus {
        /**
          * It defines the type of status to display
         */
        "type": TStatusType;
    }
    interface BqStepItem {
        /**
          * It defines prefix size
         */
        "size"?: TStepsSize;
        /**
          * It defines step item appearance based on its status
         */
        "status"?: TStepItemStatus;
        /**
          * It defines the step item type used
         */
        "type"?: TStepsType;
    }
    interface BqSteps {
        /**
          * The color of the line that connects the steps. It should be a valid declarative color token.
         */
        "dividerColor": string;
        /**
          * The size of the steps
         */
        "size": TStepsSize;
        /**
          * The type of prefix element to use on the step items
         */
        "type": TStepsType;
    }
    /**
     * Toggle switches are digital on/off switches.
     * They should provide immediate results, giving users the freedom to control their preferences as needed.
     */
    interface BqSwitch {
        /**
          * If true, a background will be displayed on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * It indicates whether if the switch is `ON` by default (when the page loads)
         */
        "checked"?: boolean;
        /**
          * If true, the switch control will be disabled and no interaction will be allowed
         */
        "disabled"?: boolean;
        /**
          * If true, the component will take the full width space available on the parent container
         */
        "fullWidth"?: boolean;
        /**
          * It indicates how to to display the on/off marks inside the control, with icons or none (default)
         */
        "innerLabel"?: TSwitchInnerLabel;
        /**
          * It defines how to distribute the space between and around the control and the label text (https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content)
         */
        "justifyContent"?: TSwitchJustifyContent;
        /**
          * Name of the form control. Submitted with the form as part of a name/value pair
         */
        "name": string;
        /**
          * If `true`, it will indicate that the user must switch `ON` the element before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * If true, the order of the control and the label text will be changed
         */
        "reverseOrder"?: boolean;
        /**
          * Remove focus from the native `<input>` HTML element used under the hood. Use this method instead of the global `element.blur()`.
         */
        "vBlur": () => Promise<void>;
        /**
          * Simulate a click event on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.click()`.
         */
        "vClick": () => Promise<void>;
        /**
          * Sets focus on the native `<input>` HTML element used under the hood. Use this method instead of the global `element.focus()`.
         */
        "vFocus": () => Promise<void>;
        /**
          * The input control's value, submitted as a name/value pair with form data.
         */
        "value"?: string;
    }
    interface BqTab {
        /**
          * If true tab is active
         */
        "active"?: boolean;
        /**
          * The tab panel id that the tab controls
         */
        "controls": string;
        /**
          * If true tab is disabled
         */
        "disabled": boolean;
        /**
          * Sets tabindex on the native `<button>` HTML element used under the hood. This method is used inside `<bq-tab-group>` to make tab focusable after the active one is focused
         */
        "enableFocus": (value: boolean) => Promise<void>;
        /**
          * The size of the tab
         */
        "size": TTabSize;
        /**
          * The id of the tab
         */
        "tabId": string;
        /**
          * Remove focus from the native `<button>` HTML element used under the hood. Use this method instead of the global `element.blur()`.
         */
        "vBlur": () => Promise<void>;
        /**
          * Simulate a click event on the native `<button>` HTML element used under the hood. Use this method instead of the global `element.click()`.
         */
        "vClick": () => Promise<void>;
        /**
          * Sets focus on the native `<button>` HTML element used under the hood. Use this method instead of the global `element.focus()`.
         */
        "vFocus": () => Promise<void>;
    }
    interface BqTabGroup {
        /**
          * A number representing the delay value applied to bqChange event handler
         */
        "debounceTime": number;
        /**
          * If true, the underline divider below the tabs won't be shown
         */
        "disableDivider": boolean;
        /**
          * The size of the tab
         */
        "size": TTabSize;
        /**
          * A string representing the id of the selected tab.
         */
        "value": string;
    }
    interface BqTag {
        /**
          * The corner radius of the Tag (will override size's predefined border)
         */
        "border": TTagBorderRadius;
        /**
          * If true, the Tag can be clickable
         */
        "clickable": boolean;
        /**
          * The color style of the Tag
         */
        "color": TTagColor;
        /**
          * If true, the Tag will be disabled (only if clickable = `true`, no interaction allowed)
         */
        "disabled"?: boolean;
        /**
          * If true, the Tag component will hidden (only if removable = `true`)
         */
        "hidden": boolean;
        /**
          * Method to be called to remove the tag component
         */
        "hide": () => Promise<void>;
        /**
          * If true, the Tag component can be removed
         */
        "removable": boolean;
        /**
          * If true, the Tag is selected (only if clickable = `true`)
         */
        "selected": boolean;
        /**
          * Method to be called to show the tag component
         */
        "show": () => Promise<void>;
        /**
          * The size of the Tag component
         */
        "size": TTagSize;
        /**
          * The variant of Tag to apply on top of the variant
         */
        "variant": TTagVariant;
    }
    interface BqTextarea {
        /**
          * If `true`, the textarea will automatically grow and shrink to fit its contents. If `false`, the textarea will have a fixed height specified by the `rows` property.
         */
        "autoGrow": boolean;
        /**
          * Controls whether or not the textarea field should be capitalized and how. Possible values are 'off', 'none', 'on', 'sentences', 'words', and 'characters'. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize
         */
        "autocapitalize": TTextareaAutoCapitalize;
        /**
          * Specifies whether or not the textarea field should have autocomplete enabled. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values
         */
        "autocomplete": string;
        /**
          * Controls whether or not the textarea field should have autocorrect enabled. Possible values are 'on' and 'off'.
         */
        "autocorrect": 'on' | 'off';
        /**
          * If true, the textarea will be focused on component render
         */
        "autofocus": boolean;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `bqInput` event after the textarea value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If `true`, it will block the user's ability to resize the textarea.
         */
        "disableResize"?: boolean;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled": boolean;
        /**
          * The ID of the form that the textarea field belongs to.
         */
        "form"?: string;
        /**
          * The maximum number of characters that can be entered into the textarea (`0`: no limit). When enabled, a character counter will be shown underneath the textarea.
         */
        "maxlength": number;
        /**
          * The name of the textarea element.
         */
        "name": string;
        /**
          * The placeholder text to show when there is no value.
         */
        "placeholder": string;
        /**
          * If true, the textarea field cannot be modified.
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the textarea field is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * The number of visible text lines for the control. It must be a positive integer.
         */
        "rows": number;
        /**
          * If true, the textarea content may be checked for spelling errors.
         */
        "spellcheck": boolean;
        /**
          * The validation status of the textarea.
          * @remarks This property is used to indicate the validation status of the textarea. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The textarea has a validation error. - `'warning'`: The textarea has a validation warning. - `'success'`: The textarea has passed validation.
         */
        "validationStatus": TInputValidation;
        /**
          * The value of the textarea. It can be used to reset the textarea to a previous value.
         */
        "value": string;
        /**
          * Specifies how the text in a text area is to be wrapped when submitted in a form
         */
        "wrap": TTextareaWrap;
    }
    interface BqToast {
        /**
          * The corder radius of the toast component
         */
        "border": TToastBorderRadius;
        /**
          * Method to be called to hide the toast component
         */
        "hide": () => Promise<void>;
        /**
          * If true will hide toast icon
         */
        "hideIcon": boolean;
        /**
          * If true, the toast will be shown
         */
        "open": boolean;
        /**
          * Placement of toast
         */
        "placement": TToastPlacement;
        /**
          * Method to be called to show the toast component
         */
        "show": () => Promise<void>;
        /**
          * The length of time, in milliseconds, after which the toast will close itself
         */
        "time": number;
        /**
          * This method can be used to display toasts in a fixed-position element that allows for stacking multiple toasts vertically
         */
        "toast": () => Promise<void>;
        /**
          * Type of toast
         */
        "type": TToastType;
    }
    interface BqTooltip {
        /**
          * If true, the tooltip will always be visible
         */
        "alwaysVisible"?: boolean;
        /**
          * Set the action when the tooltip should be displayed, on hover (default) or click
         */
        "displayOn": 'click' | 'hover';
        /**
          * Distance between trigger element and tooltip
         */
        "distance"?: number;
        /**
          * Hides the tooltip
         */
        "hide": () => Promise<void>;
        /**
          * If true, the arrow on the tooltip content won't be shown
         */
        "hideArrow"?: boolean;
        "placement"?: FloatingUIPlacement;
        /**
          * Whether the tooltip should have the same width as the trigger element (applicable only for content shorter than the trigger element)
         */
        "sameWidth"?: boolean;
        /**
          * Shows the tooltip
         */
        "show": () => Promise<void>;
        /**
          * Indicates whether or not the tooltip is visible when the component is first rendered, and when interacting with the trigger
         */
        "visible"?: boolean;
    }
}
export interface BqAccordionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqAccordionElement;
}
export interface BqAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqAlertElement;
}
export interface BqBreadcrumbCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqBreadcrumbElement;
}
export interface BqBreadcrumbItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqBreadcrumbItemElement;
}
export interface BqButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqButtonElement;
}
export interface BqCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqCheckboxElement;
}
export interface BqDatePickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqDatePickerElement;
}
export interface BqDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqDialogElement;
}
export interface BqDrawerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqDrawerElement;
}
export interface BqDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqDropdownElement;
}
export interface BqIconCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqIconElement;
}
export interface BqInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqInputElement;
}
export interface BqNotificationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqNotificationElement;
}
export interface BqOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqOptionElement;
}
export interface BqOptionListCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqOptionListElement;
}
export interface BqRadioCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqRadioElement;
}
export interface BqRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqRadioGroupElement;
}
export interface BqSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqSelectElement;
}
export interface BqSideMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqSideMenuElement;
}
export interface BqSideMenuItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqSideMenuItemElement;
}
export interface BqSliderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqSliderElement;
}
export interface BqStepItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqStepItemElement;
}
export interface BqSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqSwitchElement;
}
export interface BqTabCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqTabElement;
}
export interface BqTabGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqTabGroupElement;
}
export interface BqTagCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqTagElement;
}
export interface BqTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqTextareaElement;
}
export interface BqToastCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBqToastElement;
}
declare global {
    interface HTMLBqAccordionElementEventMap {
        "bqBlur": HTMLBqAccordionElement;
        "bqFocus": HTMLBqAccordionElement;
        "bqOpen": HTMLBqAccordionElement;
        "bqAfterOpen": HTMLBqAccordionElement;
        "bqClose": HTMLBqAccordionElement;
        "bqAfterClose": HTMLBqAccordionElement;
        "bqClick": HTMLBqAccordionElement;
    }
    interface HTMLBqAccordionElement extends Components.BqAccordion, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqAccordionElementEventMap>(type: K, listener: (this: HTMLBqAccordionElement, ev: BqAccordionCustomEvent<HTMLBqAccordionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqAccordionElementEventMap>(type: K, listener: (this: HTMLBqAccordionElement, ev: BqAccordionCustomEvent<HTMLBqAccordionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqAccordionElement: {
        prototype: HTMLBqAccordionElement;
        new (): HTMLBqAccordionElement;
    };
    interface HTMLBqAccordionGroupElement extends Components.BqAccordionGroup, HTMLStencilElement {
    }
    var HTMLBqAccordionGroupElement: {
        prototype: HTMLBqAccordionGroupElement;
        new (): HTMLBqAccordionGroupElement;
    };
    interface HTMLBqAlertElementEventMap {
        "bqHide": any;
        "bqShow": any;
        "bqAfterOpen": any;
        "bqAfterClose": any;
    }
    interface HTMLBqAlertElement extends Components.BqAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqAlertElementEventMap>(type: K, listener: (this: HTMLBqAlertElement, ev: BqAlertCustomEvent<HTMLBqAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqAlertElementEventMap>(type: K, listener: (this: HTMLBqAlertElement, ev: BqAlertCustomEvent<HTMLBqAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqAlertElement: {
        prototype: HTMLBqAlertElement;
        new (): HTMLBqAlertElement;
    };
    interface HTMLBqAvatarElement extends Components.BqAvatar, HTMLStencilElement {
    }
    var HTMLBqAvatarElement: {
        prototype: HTMLBqAvatarElement;
        new (): HTMLBqAvatarElement;
    };
    interface HTMLBqBadgeElement extends Components.BqBadge, HTMLStencilElement {
    }
    var HTMLBqBadgeElement: {
        prototype: HTMLBqBadgeElement;
        new (): HTMLBqBadgeElement;
    };
    interface HTMLBqBreadcrumbElementEventMap {
        "bqBreadcrumbBlur": HTMLBqBreadcrumbItemElement;
        "bqBreadcrumbFocus": HTMLBqBreadcrumbItemElement;
        "bqBreadcrumbClick": HTMLBqBreadcrumbItemElement;
    }
    interface HTMLBqBreadcrumbElement extends Components.BqBreadcrumb, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqBreadcrumbElementEventMap>(type: K, listener: (this: HTMLBqBreadcrumbElement, ev: BqBreadcrumbCustomEvent<HTMLBqBreadcrumbElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqBreadcrumbElementEventMap>(type: K, listener: (this: HTMLBqBreadcrumbElement, ev: BqBreadcrumbCustomEvent<HTMLBqBreadcrumbElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqBreadcrumbElement: {
        prototype: HTMLBqBreadcrumbElement;
        new (): HTMLBqBreadcrumbElement;
    };
    interface HTMLBqBreadcrumbItemElementEventMap {
        "bqBlur": HTMLBqBreadcrumbItemElement;
        "bqFocus": HTMLBqBreadcrumbItemElement;
        "bqClick": HTMLBqBreadcrumbItemElement;
    }
    interface HTMLBqBreadcrumbItemElement extends Components.BqBreadcrumbItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqBreadcrumbItemElementEventMap>(type: K, listener: (this: HTMLBqBreadcrumbItemElement, ev: BqBreadcrumbItemCustomEvent<HTMLBqBreadcrumbItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqBreadcrumbItemElementEventMap>(type: K, listener: (this: HTMLBqBreadcrumbItemElement, ev: BqBreadcrumbItemCustomEvent<HTMLBqBreadcrumbItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqBreadcrumbItemElement: {
        prototype: HTMLBqBreadcrumbItemElement;
        new (): HTMLBqBreadcrumbItemElement;
    };
    interface HTMLBqButtonElementEventMap {
        "bqBlur": HTMLBqButtonElement;
        "bqFocus": HTMLBqButtonElement;
        "bqClick": HTMLBqButtonElement;
    }
    /**
     * Buttons are designed for users to take action on a page or a screen.
     */
    interface HTMLBqButtonElement extends Components.BqButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqButtonElementEventMap>(type: K, listener: (this: HTMLBqButtonElement, ev: BqButtonCustomEvent<HTMLBqButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqButtonElementEventMap>(type: K, listener: (this: HTMLBqButtonElement, ev: BqButtonCustomEvent<HTMLBqButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqButtonElement: {
        prototype: HTMLBqButtonElement;
        new (): HTMLBqButtonElement;
    };
    interface HTMLBqCardElement extends Components.BqCard, HTMLStencilElement {
    }
    var HTMLBqCardElement: {
        prototype: HTMLBqCardElement;
        new (): HTMLBqCardElement;
    };
    interface HTMLBqCheckboxElementEventMap {
        "bqChange": { checked: boolean };
        "bqFocus": HTMLBqCheckboxElement;
        "bqBlur": HTMLBqCheckboxElement;
    }
    interface HTMLBqCheckboxElement extends Components.BqCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqCheckboxElementEventMap>(type: K, listener: (this: HTMLBqCheckboxElement, ev: BqCheckboxCustomEvent<HTMLBqCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqCheckboxElementEventMap>(type: K, listener: (this: HTMLBqCheckboxElement, ev: BqCheckboxCustomEvent<HTMLBqCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqCheckboxElement: {
        prototype: HTMLBqCheckboxElement;
        new (): HTMLBqCheckboxElement;
    };
    interface HTMLBqDatePickerElementEventMap {
        "bqBlur": HTMLBqInputElement;
        "bqChange": { value: string | number | string[]; el: HTMLBqInputElement };
        "bqClear": HTMLBqInputElement;
        "bqFocus": HTMLBqInputElement;
        "bqInput": { value: string | number | string[]; el: HTMLBqInputElement };
    }
    interface HTMLBqDatePickerElement extends Components.BqDatePicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqDatePickerElementEventMap>(type: K, listener: (this: HTMLBqDatePickerElement, ev: BqDatePickerCustomEvent<HTMLBqDatePickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqDatePickerElementEventMap>(type: K, listener: (this: HTMLBqDatePickerElement, ev: BqDatePickerCustomEvent<HTMLBqDatePickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqDatePickerElement: {
        prototype: HTMLBqDatePickerElement;
        new (): HTMLBqDatePickerElement;
    };
    interface HTMLBqDialogElementEventMap {
        "bqCancel": void;
        "bqClose": void;
        "bqOpen": void;
        "bqAfterOpen": void;
        "bqAfterClose": void;
    }
    interface HTMLBqDialogElement extends Components.BqDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqDialogElementEventMap>(type: K, listener: (this: HTMLBqDialogElement, ev: BqDialogCustomEvent<HTMLBqDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqDialogElementEventMap>(type: K, listener: (this: HTMLBqDialogElement, ev: BqDialogCustomEvent<HTMLBqDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqDialogElement: {
        prototype: HTMLBqDialogElement;
        new (): HTMLBqDialogElement;
    };
    interface HTMLBqDividerElement extends Components.BqDivider, HTMLStencilElement {
    }
    var HTMLBqDividerElement: {
        prototype: HTMLBqDividerElement;
        new (): HTMLBqDividerElement;
    };
    interface HTMLBqDrawerElementEventMap {
        "bqClose": any;
        "bqOpen": any;
        "bqAfterOpen": any;
        "bqAfterClose": any;
    }
    interface HTMLBqDrawerElement extends Components.BqDrawer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqDrawerElementEventMap>(type: K, listener: (this: HTMLBqDrawerElement, ev: BqDrawerCustomEvent<HTMLBqDrawerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqDrawerElementEventMap>(type: K, listener: (this: HTMLBqDrawerElement, ev: BqDrawerCustomEvent<HTMLBqDrawerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqDrawerElement: {
        prototype: HTMLBqDrawerElement;
        new (): HTMLBqDrawerElement;
    };
    interface HTMLBqDropdownElementEventMap {
        "bqOpen": { open: boolean };
    }
    interface HTMLBqDropdownElement extends Components.BqDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqDropdownElementEventMap>(type: K, listener: (this: HTMLBqDropdownElement, ev: BqDropdownCustomEvent<HTMLBqDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqDropdownElementEventMap>(type: K, listener: (this: HTMLBqDropdownElement, ev: BqDropdownCustomEvent<HTMLBqDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqDropdownElement: {
        prototype: HTMLBqDropdownElement;
        new (): HTMLBqDropdownElement;
    };
    interface HTMLBqEmptyStateElement extends Components.BqEmptyState, HTMLStencilElement {
    }
    var HTMLBqEmptyStateElement: {
        prototype: HTMLBqEmptyStateElement;
        new (): HTMLBqEmptyStateElement;
    };
    interface HTMLBqIconElementEventMap {
        "svgLoaded": any;
    }
    /**
     * Icons are simplified images that graphically explain the meaning of an object on the screen.
     */
    interface HTMLBqIconElement extends Components.BqIcon, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqIconElementEventMap>(type: K, listener: (this: HTMLBqIconElement, ev: BqIconCustomEvent<HTMLBqIconElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqIconElementEventMap>(type: K, listener: (this: HTMLBqIconElement, ev: BqIconCustomEvent<HTMLBqIconElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqIconElement: {
        prototype: HTMLBqIconElement;
        new (): HTMLBqIconElement;
    };
    interface HTMLBqInputElementEventMap {
        "bqBlur": HTMLBqInputElement;
        "bqChange": { value: string | number | string[]; el: HTMLBqInputElement };
        "bqClear": HTMLBqInputElement;
        "bqFocus": HTMLBqInputElement;
        "bqInput": { value: string | number | string[]; el: HTMLBqInputElement };
    }
    interface HTMLBqInputElement extends Components.BqInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqInputElementEventMap>(type: K, listener: (this: HTMLBqInputElement, ev: BqInputCustomEvent<HTMLBqInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqInputElementEventMap>(type: K, listener: (this: HTMLBqInputElement, ev: BqInputCustomEvent<HTMLBqInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqInputElement: {
        prototype: HTMLBqInputElement;
        new (): HTMLBqInputElement;
    };
    interface HTMLBqNotificationElementEventMap {
        "bqHide": any;
        "bqShow": any;
        "bqAfterOpen": any;
        "bqAfterClose": any;
    }
    interface HTMLBqNotificationElement extends Components.BqNotification, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqNotificationElementEventMap>(type: K, listener: (this: HTMLBqNotificationElement, ev: BqNotificationCustomEvent<HTMLBqNotificationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqNotificationElementEventMap>(type: K, listener: (this: HTMLBqNotificationElement, ev: BqNotificationCustomEvent<HTMLBqNotificationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqNotificationElement: {
        prototype: HTMLBqNotificationElement;
        new (): HTMLBqNotificationElement;
    };
    interface HTMLBqOptionElementEventMap {
        "bqBlur": HTMLBqOptionElement;
        "bqFocus": HTMLBqOptionElement;
        "bqClick": HTMLBqOptionElement;
        "bqEnter": HTMLBqOptionElement;
    }
    interface HTMLBqOptionElement extends Components.BqOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqOptionElementEventMap>(type: K, listener: (this: HTMLBqOptionElement, ev: BqOptionCustomEvent<HTMLBqOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqOptionElementEventMap>(type: K, listener: (this: HTMLBqOptionElement, ev: BqOptionCustomEvent<HTMLBqOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqOptionElement: {
        prototype: HTMLBqOptionElement;
        new (): HTMLBqOptionElement;
    };
    interface HTMLBqOptionGroupElement extends Components.BqOptionGroup, HTMLStencilElement {
    }
    var HTMLBqOptionGroupElement: {
        prototype: HTMLBqOptionGroupElement;
        new (): HTMLBqOptionGroupElement;
    };
    interface HTMLBqOptionListElementEventMap {
        "bqSelect": { value: string; item: HTMLBqOptionElement };
    }
    interface HTMLBqOptionListElement extends Components.BqOptionList, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqOptionListElementEventMap>(type: K, listener: (this: HTMLBqOptionListElement, ev: BqOptionListCustomEvent<HTMLBqOptionListElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqOptionListElementEventMap>(type: K, listener: (this: HTMLBqOptionListElement, ev: BqOptionListCustomEvent<HTMLBqOptionListElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqOptionListElement: {
        prototype: HTMLBqOptionListElement;
        new (): HTMLBqOptionListElement;
    };
    interface HTMLBqPanelElement extends Components.BqPanel, HTMLStencilElement {
    }
    var HTMLBqPanelElement: {
        prototype: HTMLBqPanelElement;
        new (): HTMLBqPanelElement;
    };
    interface HTMLBqProgressElement extends Components.BqProgress, HTMLStencilElement {
    }
    var HTMLBqProgressElement: {
        prototype: HTMLBqProgressElement;
        new (): HTMLBqProgressElement;
    };
    interface HTMLBqRadioElementEventMap {
        "bqClick": HTMLBqRadioElement;
        "bqFocus": HTMLBqRadioElement;
        "bqBlur": HTMLBqRadioElement;
        "bqKeyDown": KeyboardEvent;
    }
    interface HTMLBqRadioElement extends Components.BqRadio, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqRadioElementEventMap>(type: K, listener: (this: HTMLBqRadioElement, ev: BqRadioCustomEvent<HTMLBqRadioElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqRadioElementEventMap>(type: K, listener: (this: HTMLBqRadioElement, ev: BqRadioCustomEvent<HTMLBqRadioElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqRadioElement: {
        prototype: HTMLBqRadioElement;
        new (): HTMLBqRadioElement;
    };
    interface HTMLBqRadioGroupElementEventMap {
        "bqChange": { value: string; target: HTMLBqRadioElement };
    }
    interface HTMLBqRadioGroupElement extends Components.BqRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqRadioGroupElementEventMap>(type: K, listener: (this: HTMLBqRadioGroupElement, ev: BqRadioGroupCustomEvent<HTMLBqRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqRadioGroupElementEventMap>(type: K, listener: (this: HTMLBqRadioGroupElement, ev: BqRadioGroupCustomEvent<HTMLBqRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqRadioGroupElement: {
        prototype: HTMLBqRadioGroupElement;
        new (): HTMLBqRadioGroupElement;
    };
    interface HTMLBqSelectElementEventMap {
        "bqBlur": HTMLBqSelectElement;
        "bqClear": HTMLBqSelectElement;
        "bqFocus": HTMLBqSelectElement;
        "bqSelect": { value: string | number | string[]; item: HTMLBqOptionElement };
    }
    interface HTMLBqSelectElement extends Components.BqSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqSelectElementEventMap>(type: K, listener: (this: HTMLBqSelectElement, ev: BqSelectCustomEvent<HTMLBqSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqSelectElementEventMap>(type: K, listener: (this: HTMLBqSelectElement, ev: BqSelectCustomEvent<HTMLBqSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqSelectElement: {
        prototype: HTMLBqSelectElement;
        new (): HTMLBqSelectElement;
    };
    interface HTMLBqSideMenuElementEventMap {
        "bqCollapse": { collapse: boolean };
        "bqSelect": HTMLBqSideMenuItemElement;
    }
    interface HTMLBqSideMenuElement extends Components.BqSideMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqSideMenuElementEventMap>(type: K, listener: (this: HTMLBqSideMenuElement, ev: BqSideMenuCustomEvent<HTMLBqSideMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqSideMenuElementEventMap>(type: K, listener: (this: HTMLBqSideMenuElement, ev: BqSideMenuCustomEvent<HTMLBqSideMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqSideMenuElement: {
        prototype: HTMLBqSideMenuElement;
        new (): HTMLBqSideMenuElement;
    };
    interface HTMLBqSideMenuItemElementEventMap {
        "bqBlur": HTMLBqSideMenuItemElement;
        "bqFocus": HTMLBqSideMenuItemElement;
        "bqClick": HTMLBqSideMenuItemElement;
    }
    interface HTMLBqSideMenuItemElement extends Components.BqSideMenuItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqSideMenuItemElementEventMap>(type: K, listener: (this: HTMLBqSideMenuItemElement, ev: BqSideMenuItemCustomEvent<HTMLBqSideMenuItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqSideMenuItemElementEventMap>(type: K, listener: (this: HTMLBqSideMenuItemElement, ev: BqSideMenuItemCustomEvent<HTMLBqSideMenuItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqSideMenuItemElement: {
        prototype: HTMLBqSideMenuItemElement;
        new (): HTMLBqSideMenuItemElement;
    };
    interface HTMLBqSliderElementEventMap {
        "bqChange": { value: Exclude<TSliderValue, string>; el: HTMLBqSliderElement };
        "bqBlur": HTMLBqSliderElement;
        "bqFocus": HTMLBqSliderElement;
    }
    interface HTMLBqSliderElement extends Components.BqSlider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqSliderElementEventMap>(type: K, listener: (this: HTMLBqSliderElement, ev: BqSliderCustomEvent<HTMLBqSliderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqSliderElementEventMap>(type: K, listener: (this: HTMLBqSliderElement, ev: BqSliderCustomEvent<HTMLBqSliderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqSliderElement: {
        prototype: HTMLBqSliderElement;
        new (): HTMLBqSliderElement;
    };
    /**
     * Spinners are designed for users to display data loading.
     */
    interface HTMLBqSpinnerElement extends Components.BqSpinner, HTMLStencilElement {
    }
    var HTMLBqSpinnerElement: {
        prototype: HTMLBqSpinnerElement;
        new (): HTMLBqSpinnerElement;
    };
    interface HTMLBqStatusElement extends Components.BqStatus, HTMLStencilElement {
    }
    var HTMLBqStatusElement: {
        prototype: HTMLBqStatusElement;
        new (): HTMLBqStatusElement;
    };
    interface HTMLBqStepItemElementEventMap {
        "bqClick": { target: HTMLBqStepItemElement; value: string };
    }
    interface HTMLBqStepItemElement extends Components.BqStepItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqStepItemElementEventMap>(type: K, listener: (this: HTMLBqStepItemElement, ev: BqStepItemCustomEvent<HTMLBqStepItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqStepItemElementEventMap>(type: K, listener: (this: HTMLBqStepItemElement, ev: BqStepItemCustomEvent<HTMLBqStepItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqStepItemElement: {
        prototype: HTMLBqStepItemElement;
        new (): HTMLBqStepItemElement;
    };
    interface HTMLBqStepsElement extends Components.BqSteps, HTMLStencilElement {
    }
    var HTMLBqStepsElement: {
        prototype: HTMLBqStepsElement;
        new (): HTMLBqStepsElement;
    };
    interface HTMLBqSwitchElementEventMap {
        "bqChange": { checked: boolean };
        "bqFocus": HTMLBqSwitchElement;
        "bqBlur": HTMLBqSwitchElement;
    }
    /**
     * Toggle switches are digital on/off switches.
     * They should provide immediate results, giving users the freedom to control their preferences as needed.
     */
    interface HTMLBqSwitchElement extends Components.BqSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqSwitchElementEventMap>(type: K, listener: (this: HTMLBqSwitchElement, ev: BqSwitchCustomEvent<HTMLBqSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqSwitchElementEventMap>(type: K, listener: (this: HTMLBqSwitchElement, ev: BqSwitchCustomEvent<HTMLBqSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqSwitchElement: {
        prototype: HTMLBqSwitchElement;
        new (): HTMLBqSwitchElement;
    };
    interface HTMLBqTabElementEventMap {
        "bqClick": HTMLBqTabElement;
        "bqFocus": HTMLBqTabElement;
        "bqBlur": HTMLBqTabElement;
        "bqKeyDown": KeyboardEvent;
    }
    interface HTMLBqTabElement extends Components.BqTab, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqTabElementEventMap>(type: K, listener: (this: HTMLBqTabElement, ev: BqTabCustomEvent<HTMLBqTabElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqTabElementEventMap>(type: K, listener: (this: HTMLBqTabElement, ev: BqTabCustomEvent<HTMLBqTabElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqTabElement: {
        prototype: HTMLBqTabElement;
        new (): HTMLBqTabElement;
    };
    interface HTMLBqTabGroupElementEventMap {
        "bqChange": { target: HTMLBqTabElement; value: string };
    }
    interface HTMLBqTabGroupElement extends Components.BqTabGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqTabGroupElementEventMap>(type: K, listener: (this: HTMLBqTabGroupElement, ev: BqTabGroupCustomEvent<HTMLBqTabGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqTabGroupElementEventMap>(type: K, listener: (this: HTMLBqTabGroupElement, ev: BqTabGroupCustomEvent<HTMLBqTabGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqTabGroupElement: {
        prototype: HTMLBqTabGroupElement;
        new (): HTMLBqTabGroupElement;
    };
    interface HTMLBqTagElementEventMap {
        "bqClose": any;
        "bqOpen": any;
        "bqBlur": HTMLBqTagElement;
        "bqClick": HTMLBqTagElement;
        "bqFocus": HTMLBqTagElement;
    }
    interface HTMLBqTagElement extends Components.BqTag, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqTagElementEventMap>(type: K, listener: (this: HTMLBqTagElement, ev: BqTagCustomEvent<HTMLBqTagElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqTagElementEventMap>(type: K, listener: (this: HTMLBqTagElement, ev: BqTagCustomEvent<HTMLBqTagElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqTagElement: {
        prototype: HTMLBqTagElement;
        new (): HTMLBqTagElement;
    };
    interface HTMLBqTextareaElementEventMap {
        "bqBlur": HTMLBqTextareaElement;
        "bqChange": { value: string; el: HTMLBqTextareaElement };
        "bqClear": HTMLBqTextareaElement;
        "bqFocus": HTMLBqTextareaElement;
        "bqInput": { value: string; el: HTMLBqTextareaElement };
    }
    interface HTMLBqTextareaElement extends Components.BqTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqTextareaElementEventMap>(type: K, listener: (this: HTMLBqTextareaElement, ev: BqTextareaCustomEvent<HTMLBqTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqTextareaElementEventMap>(type: K, listener: (this: HTMLBqTextareaElement, ev: BqTextareaCustomEvent<HTMLBqTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqTextareaElement: {
        prototype: HTMLBqTextareaElement;
        new (): HTMLBqTextareaElement;
    };
    interface HTMLBqToastElementEventMap {
        "bqHide": HTMLBqToastElement;
        "bqShow": HTMLBqToastElement;
    }
    interface HTMLBqToastElement extends Components.BqToast, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBqToastElementEventMap>(type: K, listener: (this: HTMLBqToastElement, ev: BqToastCustomEvent<HTMLBqToastElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBqToastElementEventMap>(type: K, listener: (this: HTMLBqToastElement, ev: BqToastCustomEvent<HTMLBqToastElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBqToastElement: {
        prototype: HTMLBqToastElement;
        new (): HTMLBqToastElement;
    };
    interface HTMLBqTooltipElement extends Components.BqTooltip, HTMLStencilElement {
    }
    var HTMLBqTooltipElement: {
        prototype: HTMLBqTooltipElement;
        new (): HTMLBqTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "bq-accordion": HTMLBqAccordionElement;
        "bq-accordion-group": HTMLBqAccordionGroupElement;
        "bq-alert": HTMLBqAlertElement;
        "bq-avatar": HTMLBqAvatarElement;
        "bq-badge": HTMLBqBadgeElement;
        "bq-breadcrumb": HTMLBqBreadcrumbElement;
        "bq-breadcrumb-item": HTMLBqBreadcrumbItemElement;
        "bq-button": HTMLBqButtonElement;
        "bq-card": HTMLBqCardElement;
        "bq-checkbox": HTMLBqCheckboxElement;
        "bq-date-picker": HTMLBqDatePickerElement;
        "bq-dialog": HTMLBqDialogElement;
        "bq-divider": HTMLBqDividerElement;
        "bq-drawer": HTMLBqDrawerElement;
        "bq-dropdown": HTMLBqDropdownElement;
        "bq-empty-state": HTMLBqEmptyStateElement;
        "bq-icon": HTMLBqIconElement;
        "bq-input": HTMLBqInputElement;
        "bq-notification": HTMLBqNotificationElement;
        "bq-option": HTMLBqOptionElement;
        "bq-option-group": HTMLBqOptionGroupElement;
        "bq-option-list": HTMLBqOptionListElement;
        "bq-panel": HTMLBqPanelElement;
        "bq-progress": HTMLBqProgressElement;
        "bq-radio": HTMLBqRadioElement;
        "bq-radio-group": HTMLBqRadioGroupElement;
        "bq-select": HTMLBqSelectElement;
        "bq-side-menu": HTMLBqSideMenuElement;
        "bq-side-menu-item": HTMLBqSideMenuItemElement;
        "bq-slider": HTMLBqSliderElement;
        "bq-spinner": HTMLBqSpinnerElement;
        "bq-status": HTMLBqStatusElement;
        "bq-step-item": HTMLBqStepItemElement;
        "bq-steps": HTMLBqStepsElement;
        "bq-switch": HTMLBqSwitchElement;
        "bq-tab": HTMLBqTabElement;
        "bq-tab-group": HTMLBqTabGroupElement;
        "bq-tag": HTMLBqTagElement;
        "bq-textarea": HTMLBqTextareaElement;
        "bq-toast": HTMLBqToastElement;
        "bq-tooltip": HTMLBqTooltipElement;
    }
}
declare namespace LocalJSX {
    interface BqAccordion {
        /**
          * The appearance style of accordion
         */
        "appearance"?: TAccordionAppearance;
        /**
          * If true accordion is disabled
         */
        "disabled"?: boolean;
        /**
          * If true accordion is expanded
         */
        "expanded"?: boolean;
        /**
          * Handler to be called after the accordion is closed
         */
        "onBqAfterClose"?: (event: BqAccordionCustomEvent<HTMLBqAccordionElement>) => void;
        /**
          * Handler to be called after the accordion is opened
         */
        "onBqAfterOpen"?: (event: BqAccordionCustomEvent<HTMLBqAccordionElement>) => void;
        /**
          * Handler to be called when the accordion loses focus
         */
        "onBqBlur"?: (event: BqAccordionCustomEvent<HTMLBqAccordionElement>) => void;
        "onBqClick"?: (event: BqAccordionCustomEvent<HTMLBqAccordionElement>) => void;
        /**
          * Handler to be called when the accordion is closed
         */
        "onBqClose"?: (event: BqAccordionCustomEvent<HTMLBqAccordionElement>) => void;
        /**
          * Handler to be called when the accordion gets focus
         */
        "onBqFocus"?: (event: BqAccordionCustomEvent<HTMLBqAccordionElement>) => void;
        /**
          * Handler to be called when the accordion is opened
         */
        "onBqOpen"?: (event: BqAccordionCustomEvent<HTMLBqAccordionElement>) => void;
        /**
          * If true accordion expand icon is rotate 180deg when expanded
         */
        "rotate"?: boolean;
        /**
          * The size of accordion
         */
        "size"?: TAccordionSize;
    }
    interface BqAccordionGroup {
        /**
          * The appearance style of accordion to be applied to all accordions
         */
        "appearance"?: TAccordionAppearance;
        /**
          * If true all accordions are expanded
         */
        "expandAll"?: boolean;
        /**
          * If true multiple accordions can be expanded at the same time
         */
        "multiple"?: boolean;
        /**
          * The size of accordion to be applied to all accordions
         */
        "size"?: TAccordionSize;
    }
    interface BqAlert {
        /**
          * If true, the alert will automatically hide after the specified amount of time
         */
        "autoDismiss"?: boolean;
        /**
          * The corner radius of the alert component
         */
        "border"?: TAlertBorderRadius;
        /**
          * If true, the close button at the top right of the alert won't be shown
         */
        "disableClose"?: boolean;
        /**
          * If true, the alert icon won't be shown
         */
        "hideIcon"?: boolean;
        /**
          * Callback handler to be called after the alert has been closed
         */
        "onBqAfterClose"?: (event: BqAlertCustomEvent<any>) => void;
        /**
          * Callback handler to be called after the alert has been opened
         */
        "onBqAfterOpen"?: (event: BqAlertCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the alert is hidden
         */
        "onBqHide"?: (event: BqAlertCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the alert is shown
         */
        "onBqShow"?: (event: BqAlertCustomEvent<any>) => void;
        /**
          * If true, the alert will be shown
         */
        "open"?: boolean;
        /**
          * If true, the alert component will remain fixed at the top of the page, occupying the full viewport
         */
        "sticky"?: boolean;
        /**
          * The length of time, in milliseconds, after which the alert will close itself. Only valid if `autoDismiss="true"`
         */
        "time"?: number;
        /**
          * Type of Alert
         */
        "type"?: TAlertType;
    }
    interface BqAvatar {
        /**
          * Alternate text for the avatar image if the image cannot be displayed
         */
        "altText"?: string;
        /**
          * The image source to load on the avatar (this can be also a base64 encoded image)
         */
        "image"?: string;
        /**
          * The text to display on avatar
         */
        "initials"?: string;
        /**
          * A text to use for describing the avatar on assistive devices
         */
        "label"?: string;
        /**
          * The shape of the avatar
         */
        "shape"?: TAvatarShape;
        /**
          * The size of the avatar
         */
        "size"?: TAvatarSize;
    }
    interface BqBadge {
        /**
          * Badge background color. The value should be a valid value of the palette color
         */
        "backgroundColor"?: string;
        /**
          * The size of the badge. Relevant if badge has no content.
         */
        "size"?: TBadgeSize;
        /**
          * Badge number color. The value should be a valid value of the palette color
         */
        "textColor"?: string;
    }
    interface BqBreadcrumb {
        /**
          * The `aria-label` attribute to describe the type of navigation
         */
        "ariaLabel"?: string;
        /**
          * Handler to be called when `bq-breadcrumb-item` item loses focus.
         */
        "onBqBreadcrumbBlur"?: (event: BqBreadcrumbCustomEvent<HTMLBqBreadcrumbItemElement>) => void;
        /**
          * Handler to be called when `bq-breadcrumb-item` is selected (on click/enter press).
         */
        "onBqBreadcrumbClick"?: (event: BqBreadcrumbCustomEvent<HTMLBqBreadcrumbItemElement>) => void;
        /**
          * Handler to be called when `bq-breadcrumb-item` item gets focus.
         */
        "onBqBreadcrumbFocus"?: (event: BqBreadcrumbCustomEvent<HTMLBqBreadcrumbItemElement>) => void;
    }
    interface BqBreadcrumbItem {
        /**
          * The aria-label that corresponds to the full title of the destination page. This won't be shown in the page, but it will be used by screen readers and other assistive devices.
         */
        "ariaLabel"?: string;
        /**
          * If set, the breadcrumb item will be rendered as an `<a>` with this `href`, otherwise, a `<button>` will be rendered.
         */
        "href"?: string;
        /**
          * If true, the item is the last element inside breadcrumb
         */
        "isLastItem"?: boolean;
        /**
          * Handler to be called when item loses focus
         */
        "onBqBlur"?: (event: BqBreadcrumbItemCustomEvent<HTMLBqBreadcrumbItemElement>) => void;
        /**
          * Handler to be called when item is clicked
         */
        "onBqClick"?: (event: BqBreadcrumbItemCustomEvent<HTMLBqBreadcrumbItemElement>) => void;
        /**
          * Handler to be called when item is focused
         */
        "onBqFocus"?: (event: BqBreadcrumbItemCustomEvent<HTMLBqBreadcrumbItemElement>) => void;
        /**
          * Where to display the link in the browser context. Relevant only if `href` is set.
         */
        "rel"?: string;
        /**
          * Where to display the link in the browser context. Relevant only if `href` is set.
         */
        "target"?: '_blank' | '_parent' | '_self' | '_top';
    }
    /**
     * Buttons are designed for users to take action on a page or a screen.
     */
    interface BqButton {
        /**
          * The appearance style to apply to the button
         */
        "appearance"?: TButtonAppearance;
        /**
          * If `true`, it will make the button fit to its parent width.
         */
        "block"?: boolean;
        /**
          * The corner radius of the button
         */
        "border"?: TButtonBorderRadius;
        /**
          * If true, the button will be disabled (no interaction allowed)
         */
        "disabled"?: boolean;
        /**
          * Tells the browser to treat the linked URL as a download. Only used when `href` is set. Details: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-download
         */
        "download"?: string;
        /**
          * When set, the underlying button will be rendered as an `<a>` with this `href` instead of a `<button>`
         */
        "href"?: string;
        /**
          * It determinate how the content should be aligned
         */
        "justifyContent"?: 'left' | 'center' | 'right';
        /**
          * If `true` it will display the button in a loading state
         */
        "loading"?: boolean;
        /**
          * Handler to be called when the button loses focus
         */
        "onBqBlur"?: (event: BqButtonCustomEvent<HTMLBqButtonElement>) => void;
        /**
          * Handler to be called when button gets focus
         */
        "onBqClick"?: (event: BqButtonCustomEvent<HTMLBqButtonElement>) => void;
        /**
          * Handler to be called when the button is clicked
         */
        "onBqFocus"?: (event: BqButtonCustomEvent<HTMLBqButtonElement>) => void;
        /**
          * The size of the button
         */
        "size"?: TButtonSize;
        /**
          * Where to display the linked URL, as the name for a browsing context (a `tab`, `window`, or `<iframe>`) Details: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-target
         */
        "target"?: '_blank' | '_parent' | '_self' | '_top';
        /**
          * The default behavior of the button
         */
        "type"?: TButtonType;
        /**
          * The variant of button to apply on top of the appearance (applicable only to `appearance="primary"`)
         */
        "variant"?: TButtonVariant;
    }
    interface BqCard {
        /**
          * The corner radius of the card component
         */
        "border"?: TCardBorderRadius;
        /**
          * Type of card component
         */
        "type"?: TCardType;
    }
    interface BqCheckbox {
        /**
          * If true checkbox displays background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * If true checkbox is checked
         */
        "checked"?: boolean;
        /**
          * If true checkbox is disabled
         */
        "disabled"?: boolean;
        /**
          * The form ID that the checkbox is associated with
         */
        "formId"?: string;
        /**
          * A state that is neither checked nor unchecked
         */
        "indeterminate"?: boolean;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * Handler to be called when the checkbox loses focus
         */
        "onBqBlur"?: (event: BqCheckboxCustomEvent<HTMLBqCheckboxElement>) => void;
        /**
          * Handler to be called when the chebkbox state changes
         */
        "onBqChange"?: (event: BqCheckboxCustomEvent<{ checked: boolean }>) => void;
        /**
          * Handler to be called when the checkbox gets focus
         */
        "onBqFocus"?: (event: BqCheckboxCustomEvent<HTMLBqCheckboxElement>) => void;
        /**
          * If `true`, it will indicate that the user must specify a value for the checkbox before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * A string representing the value of the checkbox. Primarily used to differentiate a list of related checkboxes that have the same name.
         */
        "value": string;
    }
    interface BqDatePicker {
        /**
          * If `true`, the Date picker input will be focused on component render
         */
        "autofocus"?: boolean;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * If `true`, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the Date picker input is disabled or not. If `true`, the Date picker is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the Date picker panel and the input element.
         */
        "distance"?: number;
        /**
          * The ID of the form that the Date picker input belongs to.
         */
        "form"?: string;
        /**
          * If `true`, the Date picker panel will remain open after a selection date is made.
         */
        "keepOpenOnSelect"?: boolean;
        /**
          * Number of months to show when range is `true`
         */
        "months"?: number;
        /**
          * The Date picker input name.
         */
        "name": string;
        /**
          * Callback handler emitted when the input loses focus
         */
        "onBqBlur"?: (event: BqDatePickerCustomEvent<HTMLBqInputElement>) => void;
        /**
          * Callback handler emitted when the input value has changed and the input loses focus. This handler is called whenever the user finishes typing or pasting text into the input field and then clicks outside of the input field.
         */
        "onBqChange"?: (event: BqDatePickerCustomEvent<{ value: string | number | string[]; el: HTMLBqInputElement }>) => void;
        /**
          * Callback handler emitted when the input value has been cleared
         */
        "onBqClear"?: (event: BqDatePickerCustomEvent<HTMLBqInputElement>) => void;
        /**
          * Callback handler emitted when the input has received focus
         */
        "onBqFocus"?: (event: BqDatePickerCustomEvent<HTMLBqInputElement>) => void;
        /**
          * Callback handler emitted when the input value changes. This handler is called whenever the user types or pastes text into the input field.
         */
        "onBqInput"?: (event: BqDatePickerCustomEvent<{ value: string | number | string[]; el: HTMLBqInputElement }>) => void;
        /**
          * If `true`, the Date picker panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the Date picker panel.
         */
        "panelHeight"?: string;
        /**
          * The Date picker input placeholder text value
         */
        "placeholder"?: string;
        /**
          * Position of the Date picker panel
         */
        "placement"?: FloatingUIPlacement;
        /**
          * If `true`, the Date picker panel will accepts more than 1 month to display
         */
        "range"?: boolean;
        /**
          * Indicates whether or not the Date picker input is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * Represents the skidding between the Date picker panel and the input element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the Date picker panel
         */
        "strategy"?: 'fixed' | 'absolute';
        /**
          * The validation status of the Select input.
          * @remarks This property is used to indicate the validation status of the select input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus"?: TInputValidation;
        /**
          * The select input value, it can be used to reset the field to a previous value
         */
        "value"?: TInputValue;
    }
    interface BqDialog {
        /**
          * Corder radius of the dialog component
         */
        "border"?: TDialogBorderRadius;
        /**
          * If true, the backdrop overlay won't be shown when the dialog opens
         */
        "disableBackdrop"?: boolean;
        /**
          * If true, the dialog will not close when clicking on the backdrop overlay
         */
        "disableCloseClickOutside"?: boolean;
        /**
          * If true, the dialog will not close when the [Esc] key is press
         */
        "disableCloseEscKeydown"?: boolean;
        /**
          * The appearance of footer
         */
        "footerAppearance"?: TDialogFooterAppearance;
        /**
          * If true, it hides the close button
         */
        "hideCloseButton"?: boolean;
        /**
          * Callback handler emitted when the dialog finish closing
         */
        "onBqAfterClose"?: (event: BqDialogCustomEvent<void>) => void;
        /**
          * Callback handler emitted when the dialog finish opening
         */
        "onBqAfterOpen"?: (event: BqDialogCustomEvent<void>) => void;
        /**
          * Callback handler emitted when the dialog has been canceled or dismissed
         */
        "onBqCancel"?: (event: BqDialogCustomEvent<void>) => void;
        /**
          * Callback handler emitted when the dialog will close
         */
        "onBqClose"?: (event: BqDialogCustomEvent<void>) => void;
        /**
          * Callback handler emitted when the dialog will open
         */
        "onBqOpen"?: (event: BqDialogCustomEvent<void>) => void;
        /**
          * If true, the dialog will be shown as open
         */
        "open"?: boolean;
        /**
          * The size of the dialog
         */
        "size"?: TDialogSize;
    }
    interface BqDivider {
        /**
          * If true, the divider has a dashed pattern
         */
        "dashed"?: boolean;
        /**
          * The default orientation of the divider
         */
        "orientation"?: TDividerOrientation;
        /**
          * Set the min width of the divider's stroke when text is not centered. Value expressed in px
         */
        "strokeBasis"?: number;
        /**
          * Set the stroke color of the divider. The value should be a valid value of the palette color
         */
        "strokeColor"?: string;
        /**
          * Set the gap of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeDashGap"?: number;
        /**
          * Set the width of each dash of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeDashWidth"?: number;
        /**
          * Set the line of the divider's stroke. This is applicable when the stroke is dashed
         */
        "strokeLinecap"?: TDividerStrokeLinecap;
        /**
          * Set the thickness of the divider's stroke. Value expressed in px
         */
        "strokeThickness"?: number;
        /**
          * Set the alignment of the title on the main axis of the divider (horizontal / vertical)
         */
        "titleAlignment"?: TDividerTitleAlignment;
    }
    interface BqDrawer {
        /**
          * If true, the drawer will not close when clicking outside the panel
         */
        "closeOnClickOutside"?: boolean;
        /**
          * If true, the dialog will not close when the [Esc] key is pressed
         */
        "closeOnEsc"?: boolean;
        /**
          * If true, the backdrop overlay will be shown when the drawer opens
         */
        "enableBackdrop"?: boolean;
        /**
          * Callback handler to be called after the drawer has been closed
         */
        "onBqAfterClose"?: (event: BqDrawerCustomEvent<any>) => void;
        /**
          * Callback handler to be called after the drawer has been opened
         */
        "onBqAfterOpen"?: (event: BqDrawerCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the drawer is closed
         */
        "onBqClose"?: (event: BqDrawerCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the drawer is opened
         */
        "onBqOpen"?: (event: BqDrawerCustomEvent<any>) => void;
        /**
          * If true, the drawer component will be shown
         */
        "open"?: boolean;
        /**
          * Defines the position of the drawer
         */
        "placement"?: TDrawerPlacement;
    }
    interface BqDropdown {
        /**
          * If true, the dropdown panel will be visible and won't be shown.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the panel and the trigger element.
         */
        "distance"?: number;
        /**
          * If true, the panel will remain open after a selection is made.
         */
        "keepOpenOnSelect"?: boolean;
        /**
          * Callback handler to be called when the dropdown panel is opened or closed.
         */
        "onBqOpen"?: (event: BqDropdownCustomEvent<{ open: boolean }>) => void;
        /**
          * If true, the panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the dropdown panel
         */
        "panelHeight"?: string;
        /**
          * Position of the panel
         */
        "placement"?: FloatingUIPlacement;
        /**
          * Whether the panel should have the same width as the trigger element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the panel and the trigger element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the panel
         */
        "strategy"?: 'fixed' | 'absolute';
    }
    interface BqEmptyState {
        /**
          * The size of the empty state component
         */
        "size"?: TEmptyStateSize;
    }
    /**
     * Icons are simplified images that graphically explain the meaning of an object on the screen.
     */
    interface BqIcon {
        /**
          * Set the stroke color of the SVG. The value should be a valid value of the palette color
         */
        "color"?: string;
        /**
          * Label for the icon, used for accessibility
         */
        "label"?: string;
        /**
          * Icon name to load. Please check all available icons [here](https://phosphoricons.com/)
         */
        "name": string;
        /**
          * Callback handler to be called when the SVG has loaded
         */
        "onSvgLoaded"?: (event: BqIconCustomEvent<any>) => void;
        /**
          * Set the size of the SVG
         */
        "size"?: string | number;
        /**
          * Set the source of the SVG. If the source is set, the name property will be ignored
         */
        "src"?: string;
        /**
          * It set the icon weight/style
         */
        "weight"?: TIconWeight;
    }
    interface BqInput {
        /**
          * Controls whether or not the input field should be capitalized and how. Possible values are 'off', 'none', 'on', 'sentences', 'words', and 'characters'. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize
         */
        "autocapitalize"?: string;
        /**
          * Specifies whether or not the input field should have autocomplete enabled. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values
         */
        "autocomplete"?: string;
        /**
          * Controls whether or not the input field should have autocorrect enabled. Possible values are 'on' and 'off'.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * If true, the input will be focused on component render
         */
        "autofocus"?: boolean;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `bqInput` event after the input value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If true, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the input is disabled or not. If `true`, the input is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * The ID of the form that the input field belongs to.
         */
        "form"?: string;
        /**
          * The inputmode attribute specifies what kind of input mechanism would be most helpful for users entering content into the input field. This allows a browser to display an appropriate virtual keyboard while editing. Possible values are 'none', 'text', 'decimal', 'numeric', 'tel', 'search', 'email', 'url', and 'date'.
         */
        "inputmode"?: string;
        /**
          * The maximum value that the input field can accept. Only applies to date and number input types.
         */
        "max"?: number | string;
        /**
          * The maximum number of characters that the input field can accept.
         */
        "maxlength"?: number;
        /**
          * The minimum value that the input field can accept. Only applies to date and number input types.
         */
        "min"?: number | string;
        /**
          * The minimum number of characters that the input field can accept.
         */
        "minlength"?: number;
        /**
          * The input field name.
         */
        "name": string;
        /**
          * Callback handler emitted when the input loses focus
         */
        "onBqBlur"?: (event: BqInputCustomEvent<HTMLBqInputElement>) => void;
        /**
          * Callback handler emitted when the input value has changed and the input loses focus. This handler is called whenever the user finishes typing or pasting text into the input field and then clicks outside of the input field.
         */
        "onBqChange"?: (event: BqInputCustomEvent<{ value: string | number | string[]; el: HTMLBqInputElement }>) => void;
        /**
          * Callback handler emitted when the input value has been cleared
         */
        "onBqClear"?: (event: BqInputCustomEvent<HTMLBqInputElement>) => void;
        /**
          * Callback handler emitted when the input has received focus
         */
        "onBqFocus"?: (event: BqInputCustomEvent<HTMLBqInputElement>) => void;
        /**
          * Callback handler emitted when the input value changes. This handler is called whenever the user types or pastes text into the input field.
         */
        "onBqInput"?: (event: BqInputCustomEvent<{ value: string | number | string[]; el: HTMLBqInputElement }>) => void;
        /**
          * Specifies a regular expression the form control's value should match. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/pattern
         */
        "pattern"?: string;
        /**
          * The input placeholder text value
         */
        "placeholder"?: string;
        /**
          * If true, the input field cannot be modified.
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the input field is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * A number that specifies the granularity that the value must adhere to. Valid for date, month, week, time, datetime-local, number, and range. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#step
         */
        "step"?: number | 'any';
        /**
          * The type attribute specifies the type of input field to display. Possible values are 'text', 'password', 'email', 'number', 'tel', 'search', 'url', and more. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types
         */
        "type"?: TInputType;
        /**
          * The validation status of the input.
          * @remarks This property is used to indicate the validation status of the input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus"?: TInputValidation;
        /**
          * The input value, it can be used to reset the input to a previous value
         */
        "value"?: TInputValue;
    }
    interface BqNotification {
        /**
          * If true, the notification will automatically hide after the specified amount of time
         */
        "autoDismiss"?: boolean;
        /**
          * The corder radius of the notification component
         */
        "border"?: TNotificationBorderRadius;
        /**
          * If true, the close button at the top right of the notification won't be shown
         */
        "disableClose"?: boolean;
        /**
          * If true, the notification icon won't be shown
         */
        "hideIcon"?: boolean;
        /**
          * Callback handler to be called after the notification has been closed
         */
        "onBqAfterClose"?: (event: BqNotificationCustomEvent<any>) => void;
        /**
          * Callback handler to be called after the notification has been opened
         */
        "onBqAfterOpen"?: (event: BqNotificationCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the notification is hidden
         */
        "onBqHide"?: (event: BqNotificationCustomEvent<any>) => void;
        /**
          * Callback handler to be called when the notification is shown
         */
        "onBqShow"?: (event: BqNotificationCustomEvent<any>) => void;
        /**
          * If true, the notification will be shown
         */
        "open"?: boolean;
        /**
          * The length of time, in milliseconds, after which the notification will close itself. Only valid if `autoDismiss="true"`
         */
        "time"?: number;
        /**
          * Type of Notification
         */
        "type"?: TNotificationType;
    }
    interface BqOption {
        /**
          * If true, the option is disabled.
         */
        "disabled"?: boolean;
        /**
          * If true, the option is hidden.
         */
        "hidden"?: boolean;
        /**
          * Handler to be called when item loses focus
         */
        "onBqBlur"?: (event: BqOptionCustomEvent<HTMLBqOptionElement>) => void;
        /**
          * Handler to be called when item is clicked
         */
        "onBqClick"?: (event: BqOptionCustomEvent<HTMLBqOptionElement>) => void;
        /**
          * Handler to be called on enter key press
         */
        "onBqEnter"?: (event: BqOptionCustomEvent<HTMLBqOptionElement>) => void;
        /**
          * Handler to be called when item is focused
         */
        "onBqFocus"?: (event: BqOptionCustomEvent<HTMLBqOptionElement>) => void;
        /**
          * If true, the option is selected and active.
         */
        "selected"?: boolean;
        /**
          * A string representing the value of the option. Can be used to identify the item
         */
        "value"?: string;
    }
    interface BqOptionGroup {
    }
    interface BqOptionList {
        /**
          * Aria label for the list.
         */
        "ariaLabel"?: string;
        /**
          * Handler to be called when `bq-option` is selected (on click/enter press).
         */
        "onBqSelect"?: (event: BqOptionListCustomEvent<{ value: string; item: HTMLBqOptionElement }>) => void;
    }
    interface BqPanel {
        /**
          * Represents the distance (gutter or margin) between the panel and the trigger element.
         */
        "distance"?: number;
        /**
          * If true, the panel will be visible.
         */
        "open"?: boolean;
        /**
          * Position of the panel
         */
        "placement"?: FloatingUIPlacement;
        /**
          * Whether the panel should have the same width as the trigger element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the panel and the trigger element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the panel
         */
        "strategy"?: 'fixed' | 'absolute';
    }
    interface BqProgress {
        /**
          * It will set the border style of the progress bar
         */
        "borderShape"?: TProgressBorderShape;
        /**
          * If `true`, a tooltip will be shown displaying the progress value
         */
        "enableTooltip"?: boolean;
        /**
          * If `true` the indeterminate state of progress bar is enabled
         */
        "indeterminate"?: boolean;
        /**
          * If `true`, a label text showing the value (in percentage) will be shown
         */
        "label"?: boolean;
        /**
          * Progress bar thickness
         */
        "thickness"?: TProgressThickness;
        /**
          * Progress type
         */
        "type"?: TProgressType;
        /**
          * A number representing the current value of the progress bar
         */
        "value"?: number;
    }
    interface BqRadio {
        /**
          * If true radio displays background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * If true radio input is checked
         */
        "checked"?: boolean;
        /**
          * If true radio input is disabled
         */
        "disabled"?: boolean;
        /**
          * The form ID that the radio input is associated with
         */
        "formId"?: string;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * Handler to be called when the radio loses focus
         */
        "onBqBlur"?: (event: BqRadioCustomEvent<HTMLBqRadioElement>) => void;
        /**
          * Handler to be called when the radio state changes
         */
        "onBqClick"?: (event: BqRadioCustomEvent<HTMLBqRadioElement>) => void;
        /**
          * Handler to be called when the radio gets focus
         */
        "onBqFocus"?: (event: BqRadioCustomEvent<HTMLBqRadioElement>) => void;
        /**
          * Handler to be called when the radio key is pressed
         */
        "onBqKeyDown"?: (event: BqRadioCustomEvent<KeyboardEvent>) => void;
        /**
          * If `true`, it will indicate that the user must specify a value for the radio before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * A string representing the value of the radio.
         */
        "value": string;
    }
    interface BqRadioGroup {
        /**
          * If true, all radio inputs in the group will display a background on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * A number representing the delay time (in milliseconds) that `bqChange` event handler gets triggered once the value change
         */
        "debounceTime"?: number;
        /**
          * If true radio inputs are disabled
         */
        "disabled"?: boolean;
        /**
          * If true displays fieldset
         */
        "fieldset"?: boolean;
        /**
          * Name of the HTML input form control. Submitted with the form as part of a name/value pair.
         */
        "name": string;
        /**
          * Handler to be called when the radio state changes
         */
        "onBqChange"?: (event: BqRadioGroupCustomEvent<{ value: string; target: HTMLBqRadioElement }>) => void;
        /**
          * The display orientation of the radio inputs
         */
        "orientation"?: TRadioGroupOrientation;
        /**
          * A string representing the value of the radio.
         */
        "value"?: string;
    }
    interface BqSelect {
        /**
          * If true, the Select input will be focused on component render
         */
        "autofocus"?: boolean;
        /**
          * The clear button aria label
         */
        "clearButtonLabel"?: string;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `bqInput` event after the input value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If true, the clear button won't be displayed
         */
        "disableClear"?: boolean;
        /**
          * Indicates whether the Select input is disabled or not. If `true`, the Select is disabled and cannot be interacted with.
         */
        "disabled"?: boolean;
        /**
          * Represents the distance (gutter or margin) between the Select panel and the input element.
         */
        "distance"?: number;
        /**
          * The ID of the form that the Select input belongs to.
         */
        "form"?: string;
        /**
          * If true, the Select panel will remain open after a selection is made.
         */
        "keepOpenOnSelect"?: boolean;
        /**
          * The maximum number of tags to display when multiple selection is enabled
         */
        "maxTagsVisible"?: number;
        /**
          * If true, the Select input will allow multiple selections.
         */
        "multiple"?: boolean;
        /**
          * The Select input name.
         */
        "name": string;
        /**
          * Callback handler emitted when the Select input loses focus
         */
        "onBqBlur"?: (event: BqSelectCustomEvent<HTMLBqSelectElement>) => void;
        /**
          * Callback handler emitted when the selected value has been cleared
         */
        "onBqClear"?: (event: BqSelectCustomEvent<HTMLBqSelectElement>) => void;
        /**
          * Callback handler emitted when the Select input has received focus
         */
        "onBqFocus"?: (event: BqSelectCustomEvent<HTMLBqSelectElement>) => void;
        /**
          * Callback handler emitted when the selected value has changed
         */
        "onBqSelect"?: (event: BqSelectCustomEvent<{ value: string | number | string[]; item: HTMLBqOptionElement }>) => void;
        /**
          * If true, the Select panel will be visible.
         */
        "open"?: boolean;
        /**
          * When set, it will override the height of the Select panel.
         */
        "panelHeight"?: string;
        /**
          * The Select input placeholder text value
         */
        "placeholder"?: string;
        /**
          * Position of the Select panel
         */
        "placement"?: FloatingUIPlacement;
        /**
          * If true, the list of options cannot be filtered (searching won't be available)
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the Select input is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * Whether the panel should have the Select same width as the input element
         */
        "sameWidth"?: boolean;
        /**
          * Represents the skidding between the Select panel and the input element.
         */
        "skidding"?: number;
        /**
          * Defines the strategy to position the Select panel
         */
        "strategy"?: 'fixed' | 'absolute';
        /**
          * The validation status of the Select input.
          * @remarks This property is used to indicate the validation status of the select input. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The input has a validation error. - `'warning'`: The input has a validation warning. - `'success'`: The input has passed validation.
         */
        "validationStatus"?: TInputValidation;
        /**
          * The select input value, it can be used to reset the field to a previous value
         */
        "value"?: TSelectValue;
    }
    interface BqSideMenu {
        /**
          * It sets a predefined appearance of the side menu
         */
        "appearance"?: TSideMenuAppearance;
        /**
          * If true, the container will reduce its width
         */
        "collapse"?: boolean;
        /**
          * Callback handler to be called when the Side menu changes its width from expanded to collapse and vice versa
         */
        "onBqCollapse"?: (event: BqSideMenuCustomEvent<{ collapse: boolean }>) => void;
        /**
          * Callback handler to be called when the active/selected menu item changes
         */
        "onBqSelect"?: (event: BqSideMenuCustomEvent<HTMLBqSideMenuItemElement>) => void;
        /**
          * It sets the size of the navigation menu items
         */
        "size"?: TSideMenuSize;
    }
    interface BqSideMenuItem {
        /**
          * If true, the menu item will be shown as active/selected.
         */
        "active"?: boolean;
        /**
          * If true, the item label and suffix will be hidden and the with will be reduce according to its parent
         */
        "collapse"?: boolean;
        /**
          * If true, the menu item will be disabled (no interaction allowed)
         */
        "disabled"?: boolean;
        /**
          * Handler to be called when the button loses focus
         */
        "onBqBlur"?: (event: BqSideMenuItemCustomEvent<HTMLBqSideMenuItemElement>) => void;
        /**
          * Handler to be called when button gets focus
         */
        "onBqClick"?: (event: BqSideMenuItemCustomEvent<HTMLBqSideMenuItemElement>) => void;
        /**
          * Handler to be called when the button is clicked
         */
        "onBqFocus"?: (event: BqSideMenuItemCustomEvent<HTMLBqSideMenuItemElement>) => void;
    }
    interface BqSlider {
        /**
          * The amount of time, in milliseconds, to wait to trigger the `bqChange` event after each value change.
         */
        "debounceTime"?: number;
        /**
          * If `true` the slider is disabled.
         */
        "disabled"?: boolean;
        /**
          * If `true`, a tooltip will be shown displaying the progress value
         */
        "enableTooltip"?: boolean;
        /**
          * If `true` it will show the value label on a side of the slider track area
         */
        "enableValueIndicator"?: boolean;
        /**
          * A number representing the amount to remain between the minimum and maximum values (only for range type).
         */
        "gap"?: number;
        /**
          * A number representing the max value of the slider.
         */
        "max"?: number;
        /**
          * A number representing the min value of the slider.
         */
        "min"?: number;
        /**
          * Handler to be called when the slider loses focus
         */
        "onBqBlur"?: (event: BqSliderCustomEvent<HTMLBqSliderElement>) => void;
        /**
          * Handler to be called when change the value on range inputs
         */
        "onBqChange"?: (event: BqSliderCustomEvent<{ value: Exclude<TSliderValue, string>; el: HTMLBqSliderElement }>) => void;
        /**
          * Handler to be called when the slider gets focused
         */
        "onBqFocus"?: (event: BqSliderCustomEvent<HTMLBqSliderElement>) => void;
        /**
          * A number representing the step of the slider. ⚠️ Please notice that the value (or list of values if the slider type is `range`) will be rounded to the nearest multiple of `step`.
         */
        "step"?: number;
        /**
          * If `true`, a tooltip will always display the progress value. It relies on enableTooltip and if enableTooltip is false, tooltipAlwaysVisible cannot be true.
         */
        "tooltipAlwaysVisible"?: boolean;
        /**
          * It defines the type of slider to display
         */
        "type"?: TSliderType;
        /**
          * The value of the slider. - If the slider type is `single`, the value is a number. - If the slider type is `range`, the value is an array of two numbers (the first number represents the `min` value and the second number represents the `max` value).
         */
        "value"?: TSliderValue;
    }
    /**
     * Spinners are designed for users to display data loading.
     */
    interface BqSpinner {
        /**
          * If `false`, the animation on the icon element will be stopped
         */
        "animation"?: boolean;
        /**
          * It defines the size of the icon element displayed
         */
        "size"?: TSpinnerSize;
        /**
          * It defines the position of the label text
         */
        "textPosition"?: TSpinnerTextPosition;
    }
    interface BqStatus {
        /**
          * It defines the type of status to display
         */
        "type"?: TStatusType;
    }
    interface BqStepItem {
        "onBqClick"?: (event: BqStepItemCustomEvent<{ target: HTMLBqStepItemElement; value: string }>) => void;
        /**
          * It defines prefix size
         */
        "size"?: TStepsSize;
        /**
          * It defines step item appearance based on its status
         */
        "status"?: TStepItemStatus;
        /**
          * It defines the step item type used
         */
        "type"?: TStepsType;
    }
    interface BqSteps {
        /**
          * The color of the line that connects the steps. It should be a valid declarative color token.
         */
        "dividerColor"?: string;
        /**
          * The size of the steps
         */
        "size"?: TStepsSize;
        /**
          * The type of prefix element to use on the step items
         */
        "type"?: TStepsType;
    }
    /**
     * Toggle switches are digital on/off switches.
     * They should provide immediate results, giving users the freedom to control their preferences as needed.
     */
    interface BqSwitch {
        /**
          * If true, a background will be displayed on hover
         */
        "backgroundOnHover"?: boolean;
        /**
          * It indicates whether if the switch is `ON` by default (when the page loads)
         */
        "checked"?: boolean;
        /**
          * If true, the switch control will be disabled and no interaction will be allowed
         */
        "disabled"?: boolean;
        /**
          * If true, the component will take the full width space available on the parent container
         */
        "fullWidth"?: boolean;
        /**
          * It indicates how to to display the on/off marks inside the control, with icons or none (default)
         */
        "innerLabel"?: TSwitchInnerLabel;
        /**
          * It defines how to distribute the space between and around the control and the label text (https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content)
         */
        "justifyContent"?: TSwitchJustifyContent;
        /**
          * Name of the form control. Submitted with the form as part of a name/value pair
         */
        "name": string;
        /**
          * Handler to be called when the switch loses focus
         */
        "onBqBlur"?: (event: BqSwitchCustomEvent<HTMLBqSwitchElement>) => void;
        /**
          * Handler to be called when the switch state changes
         */
        "onBqChange"?: (event: BqSwitchCustomEvent<{ checked: boolean }>) => void;
        /**
          * Handler to be called when the switch gets focus
         */
        "onBqFocus"?: (event: BqSwitchCustomEvent<HTMLBqSwitchElement>) => void;
        /**
          * If `true`, it will indicate that the user must switch `ON` the element before the owning form can be submitted
         */
        "required"?: boolean;
        /**
          * If true, the order of the control and the label text will be changed
         */
        "reverseOrder"?: boolean;
        /**
          * The input control's value, submitted as a name/value pair with form data.
         */
        "value"?: string;
    }
    interface BqTab {
        /**
          * If true tab is active
         */
        "active"?: boolean;
        /**
          * The tab panel id that the tab controls
         */
        "controls": string;
        /**
          * If true tab is disabled
         */
        "disabled"?: boolean;
        /**
          * Handler to be called when the tab loses focus
         */
        "onBqBlur"?: (event: BqTabCustomEvent<HTMLBqTabElement>) => void;
        /**
          * Handler to be called when the tab state changes
         */
        "onBqClick"?: (event: BqTabCustomEvent<HTMLBqTabElement>) => void;
        /**
          * Handler to be called when the tab gets focus
         */
        "onBqFocus"?: (event: BqTabCustomEvent<HTMLBqTabElement>) => void;
        /**
          * Handler to be called when the tab key is pressed
         */
        "onBqKeyDown"?: (event: BqTabCustomEvent<KeyboardEvent>) => void;
        /**
          * The size of the tab
         */
        "size"?: TTabSize;
        /**
          * The id of the tab
         */
        "tabId": string;
    }
    interface BqTabGroup {
        /**
          * A number representing the delay value applied to bqChange event handler
         */
        "debounceTime"?: number;
        /**
          * If true, the underline divider below the tabs won't be shown
         */
        "disableDivider"?: boolean;
        /**
          * Handler to be called when the tab value changes
         */
        "onBqChange"?: (event: BqTabGroupCustomEvent<{ target: HTMLBqTabElement; value: string }>) => void;
        /**
          * The size of the tab
         */
        "size"?: TTabSize;
        /**
          * A string representing the id of the selected tab.
         */
        "value"?: string;
    }
    interface BqTag {
        /**
          * The corner radius of the Tag (will override size's predefined border)
         */
        "border"?: TTagBorderRadius;
        /**
          * If true, the Tag can be clickable
         */
        "clickable"?: boolean;
        /**
          * The color style of the Tag
         */
        "color"?: TTagColor;
        /**
          * If true, the Tag will be disabled (only if clickable = `true`, no interaction allowed)
         */
        "disabled"?: boolean;
        /**
          * If true, the Tag component will hidden (only if removable = `true`)
         */
        "hidden"?: boolean;
        /**
          * Handler to be called when tag loses focus
         */
        "onBqBlur"?: (event: BqTagCustomEvent<HTMLBqTagElement>) => void;
        /**
          * Handler to be called when tag is clicked
         */
        "onBqClick"?: (event: BqTagCustomEvent<HTMLBqTagElement>) => void;
        /**
          * Callback handler to be called when the tag is close/hidden
         */
        "onBqClose"?: (event: BqTagCustomEvent<any>) => void;
        /**
          * Handler to be called when tag is focused
         */
        "onBqFocus"?: (event: BqTagCustomEvent<HTMLBqTagElement>) => void;
        /**
          * Callback handler to be called when the tag is not open/shown
         */
        "onBqOpen"?: (event: BqTagCustomEvent<any>) => void;
        /**
          * If true, the Tag component can be removed
         */
        "removable"?: boolean;
        /**
          * If true, the Tag is selected (only if clickable = `true`)
         */
        "selected"?: boolean;
        /**
          * The size of the Tag component
         */
        "size"?: TTagSize;
        /**
          * The variant of Tag to apply on top of the variant
         */
        "variant"?: TTagVariant;
    }
    interface BqTextarea {
        /**
          * If `true`, the textarea will automatically grow and shrink to fit its contents. If `false`, the textarea will have a fixed height specified by the `rows` property.
         */
        "autoGrow"?: boolean;
        /**
          * Controls whether or not the textarea field should be capitalized and how. Possible values are 'off', 'none', 'on', 'sentences', 'words', and 'characters'. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize
         */
        "autocapitalize"?: TTextareaAutoCapitalize;
        /**
          * Specifies whether or not the textarea field should have autocomplete enabled. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values
         */
        "autocomplete"?: string;
        /**
          * Controls whether or not the textarea field should have autocorrect enabled. Possible values are 'on' and 'off'.
         */
        "autocorrect"?: 'on' | 'off';
        /**
          * If true, the textarea will be focused on component render
         */
        "autofocus"?: boolean;
        /**
          * The amount of time, in milliseconds, to wait before emitting the `bqInput` event after the textarea value changes. A value of 0 means no debouncing will occur.
         */
        "debounceTime"?: number;
        /**
          * If `true`, it will block the user's ability to resize the textarea.
         */
        "disableResize"?: boolean;
        /**
          * If `true`, the user cannot interact with the textarea.
         */
        "disabled"?: boolean;
        /**
          * The ID of the form that the textarea field belongs to.
         */
        "form"?: string;
        /**
          * The maximum number of characters that can be entered into the textarea (`0`: no limit). When enabled, a character counter will be shown underneath the textarea.
         */
        "maxlength"?: number;
        /**
          * The name of the textarea element.
         */
        "name": string;
        /**
          * Callback handler emitted when the textarea loses focus
         */
        "onBqBlur"?: (event: BqTextareaCustomEvent<HTMLBqTextareaElement>) => void;
        /**
          * Callback handler emitted when the textarea value has changed and the textarea loses focus. This handler is called whenever the user finishes typing or pasting text into the textarea field and then clicks outside of the textarea field.
         */
        "onBqChange"?: (event: BqTextareaCustomEvent<{ value: string; el: HTMLBqTextareaElement }>) => void;
        /**
          * Callback handler emitted when the textarea value has been cleared
         */
        "onBqClear"?: (event: BqTextareaCustomEvent<HTMLBqTextareaElement>) => void;
        /**
          * Callback handler emitted when the textarea has received focus
         */
        "onBqFocus"?: (event: BqTextareaCustomEvent<HTMLBqTextareaElement>) => void;
        /**
          * Callback handler emitted when the textarea value changes. This handler is called whenever the user types or pastes text into the textarea field.
         */
        "onBqInput"?: (event: BqTextareaCustomEvent<{ value: string; el: HTMLBqTextareaElement }>) => void;
        /**
          * The placeholder text to show when there is no value.
         */
        "placeholder": string;
        /**
          * If true, the textarea field cannot be modified.
         */
        "readonly"?: boolean;
        /**
          * Indicates whether or not the textarea field is required to be filled out before submitting the form.
         */
        "required"?: boolean;
        /**
          * The number of visible text lines for the control. It must be a positive integer.
         */
        "rows"?: number;
        /**
          * If true, the textarea content may be checked for spelling errors.
         */
        "spellcheck"?: boolean;
        /**
          * The validation status of the textarea.
          * @remarks This property is used to indicate the validation status of the textarea. It can be set to one of the following values: - `'none'`: No validation status is set. - `'error'`: The textarea has a validation error. - `'warning'`: The textarea has a validation warning. - `'success'`: The textarea has passed validation.
         */
        "validationStatus"?: TInputValidation;
        /**
          * The value of the textarea. It can be used to reset the textarea to a previous value.
         */
        "value"?: string;
        /**
          * Specifies how the text in a text area is to be wrapped when submitted in a form
         */
        "wrap"?: TTextareaWrap;
    }
    interface BqToast {
        /**
          * The corder radius of the toast component
         */
        "border"?: TToastBorderRadius;
        /**
          * If true will hide toast icon
         */
        "hideIcon"?: boolean;
        /**
          * Callback handler to be called when the notification is hidden
         */
        "onBqHide"?: (event: BqToastCustomEvent<HTMLBqToastElement>) => void;
        /**
          * Callback handler to be called when the notification is shown
         */
        "onBqShow"?: (event: BqToastCustomEvent<HTMLBqToastElement>) => void;
        /**
          * If true, the toast will be shown
         */
        "open"?: boolean;
        /**
          * Placement of toast
         */
        "placement"?: TToastPlacement;
        /**
          * The length of time, in milliseconds, after which the toast will close itself
         */
        "time"?: number;
        /**
          * Type of toast
         */
        "type"?: TToastType;
    }
    interface BqTooltip {
        /**
          * If true, the tooltip will always be visible
         */
        "alwaysVisible"?: boolean;
        /**
          * Set the action when the tooltip should be displayed, on hover (default) or click
         */
        "displayOn"?: 'click' | 'hover';
        /**
          * Distance between trigger element and tooltip
         */
        "distance"?: number;
        /**
          * If true, the arrow on the tooltip content won't be shown
         */
        "hideArrow"?: boolean;
        "placement"?: FloatingUIPlacement;
        /**
          * Whether the tooltip should have the same width as the trigger element (applicable only for content shorter than the trigger element)
         */
        "sameWidth"?: boolean;
        /**
          * Indicates whether or not the tooltip is visible when the component is first rendered, and when interacting with the trigger
         */
        "visible"?: boolean;
    }
    interface IntrinsicElements {
        "bq-accordion": BqAccordion;
        "bq-accordion-group": BqAccordionGroup;
        "bq-alert": BqAlert;
        "bq-avatar": BqAvatar;
        "bq-badge": BqBadge;
        "bq-breadcrumb": BqBreadcrumb;
        "bq-breadcrumb-item": BqBreadcrumbItem;
        "bq-button": BqButton;
        "bq-card": BqCard;
        "bq-checkbox": BqCheckbox;
        "bq-date-picker": BqDatePicker;
        "bq-dialog": BqDialog;
        "bq-divider": BqDivider;
        "bq-drawer": BqDrawer;
        "bq-dropdown": BqDropdown;
        "bq-empty-state": BqEmptyState;
        "bq-icon": BqIcon;
        "bq-input": BqInput;
        "bq-notification": BqNotification;
        "bq-option": BqOption;
        "bq-option-group": BqOptionGroup;
        "bq-option-list": BqOptionList;
        "bq-panel": BqPanel;
        "bq-progress": BqProgress;
        "bq-radio": BqRadio;
        "bq-radio-group": BqRadioGroup;
        "bq-select": BqSelect;
        "bq-side-menu": BqSideMenu;
        "bq-side-menu-item": BqSideMenuItem;
        "bq-slider": BqSlider;
        "bq-spinner": BqSpinner;
        "bq-status": BqStatus;
        "bq-step-item": BqStepItem;
        "bq-steps": BqSteps;
        "bq-switch": BqSwitch;
        "bq-tab": BqTab;
        "bq-tab-group": BqTabGroup;
        "bq-tag": BqTag;
        "bq-textarea": BqTextarea;
        "bq-toast": BqToast;
        "bq-tooltip": BqTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "bq-accordion": LocalJSX.BqAccordion & JSXBase.HTMLAttributes<HTMLBqAccordionElement>;
            "bq-accordion-group": LocalJSX.BqAccordionGroup & JSXBase.HTMLAttributes<HTMLBqAccordionGroupElement>;
            "bq-alert": LocalJSX.BqAlert & JSXBase.HTMLAttributes<HTMLBqAlertElement>;
            "bq-avatar": LocalJSX.BqAvatar & JSXBase.HTMLAttributes<HTMLBqAvatarElement>;
            "bq-badge": LocalJSX.BqBadge & JSXBase.HTMLAttributes<HTMLBqBadgeElement>;
            "bq-breadcrumb": LocalJSX.BqBreadcrumb & JSXBase.HTMLAttributes<HTMLBqBreadcrumbElement>;
            "bq-breadcrumb-item": LocalJSX.BqBreadcrumbItem & JSXBase.HTMLAttributes<HTMLBqBreadcrumbItemElement>;
            /**
             * Buttons are designed for users to take action on a page or a screen.
             */
            "bq-button": LocalJSX.BqButton & JSXBase.HTMLAttributes<HTMLBqButtonElement>;
            "bq-card": LocalJSX.BqCard & JSXBase.HTMLAttributes<HTMLBqCardElement>;
            "bq-checkbox": LocalJSX.BqCheckbox & JSXBase.HTMLAttributes<HTMLBqCheckboxElement>;
            "bq-date-picker": LocalJSX.BqDatePicker & JSXBase.HTMLAttributes<HTMLBqDatePickerElement>;
            "bq-dialog": LocalJSX.BqDialog & JSXBase.HTMLAttributes<HTMLBqDialogElement>;
            "bq-divider": LocalJSX.BqDivider & JSXBase.HTMLAttributes<HTMLBqDividerElement>;
            "bq-drawer": LocalJSX.BqDrawer & JSXBase.HTMLAttributes<HTMLBqDrawerElement>;
            "bq-dropdown": LocalJSX.BqDropdown & JSXBase.HTMLAttributes<HTMLBqDropdownElement>;
            "bq-empty-state": LocalJSX.BqEmptyState & JSXBase.HTMLAttributes<HTMLBqEmptyStateElement>;
            /**
             * Icons are simplified images that graphically explain the meaning of an object on the screen.
             */
            "bq-icon": LocalJSX.BqIcon & JSXBase.HTMLAttributes<HTMLBqIconElement>;
            "bq-input": LocalJSX.BqInput & JSXBase.HTMLAttributes<HTMLBqInputElement>;
            "bq-notification": LocalJSX.BqNotification & JSXBase.HTMLAttributes<HTMLBqNotificationElement>;
            "bq-option": LocalJSX.BqOption & JSXBase.HTMLAttributes<HTMLBqOptionElement>;
            "bq-option-group": LocalJSX.BqOptionGroup & JSXBase.HTMLAttributes<HTMLBqOptionGroupElement>;
            "bq-option-list": LocalJSX.BqOptionList & JSXBase.HTMLAttributes<HTMLBqOptionListElement>;
            "bq-panel": LocalJSX.BqPanel & JSXBase.HTMLAttributes<HTMLBqPanelElement>;
            "bq-progress": LocalJSX.BqProgress & JSXBase.HTMLAttributes<HTMLBqProgressElement>;
            "bq-radio": LocalJSX.BqRadio & JSXBase.HTMLAttributes<HTMLBqRadioElement>;
            "bq-radio-group": LocalJSX.BqRadioGroup & JSXBase.HTMLAttributes<HTMLBqRadioGroupElement>;
            "bq-select": LocalJSX.BqSelect & JSXBase.HTMLAttributes<HTMLBqSelectElement>;
            "bq-side-menu": LocalJSX.BqSideMenu & JSXBase.HTMLAttributes<HTMLBqSideMenuElement>;
            "bq-side-menu-item": LocalJSX.BqSideMenuItem & JSXBase.HTMLAttributes<HTMLBqSideMenuItemElement>;
            "bq-slider": LocalJSX.BqSlider & JSXBase.HTMLAttributes<HTMLBqSliderElement>;
            /**
             * Spinners are designed for users to display data loading.
             */
            "bq-spinner": LocalJSX.BqSpinner & JSXBase.HTMLAttributes<HTMLBqSpinnerElement>;
            "bq-status": LocalJSX.BqStatus & JSXBase.HTMLAttributes<HTMLBqStatusElement>;
            "bq-step-item": LocalJSX.BqStepItem & JSXBase.HTMLAttributes<HTMLBqStepItemElement>;
            "bq-steps": LocalJSX.BqSteps & JSXBase.HTMLAttributes<HTMLBqStepsElement>;
            /**
             * Toggle switches are digital on/off switches.
             * They should provide immediate results, giving users the freedom to control their preferences as needed.
             */
            "bq-switch": LocalJSX.BqSwitch & JSXBase.HTMLAttributes<HTMLBqSwitchElement>;
            "bq-tab": LocalJSX.BqTab & JSXBase.HTMLAttributes<HTMLBqTabElement>;
            "bq-tab-group": LocalJSX.BqTabGroup & JSXBase.HTMLAttributes<HTMLBqTabGroupElement>;
            "bq-tag": LocalJSX.BqTag & JSXBase.HTMLAttributes<HTMLBqTagElement>;
            "bq-textarea": LocalJSX.BqTextarea & JSXBase.HTMLAttributes<HTMLBqTextareaElement>;
            "bq-toast": LocalJSX.BqToast & JSXBase.HTMLAttributes<HTMLBqToastElement>;
            "bq-tooltip": LocalJSX.BqTooltip & JSXBase.HTMLAttributes<HTMLBqTooltipElement>;
        }
    }
}
